module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/block-stream2/index.js":
/*!*********************************************!*\
  !*** ./node_modules/block-stream2/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"inherits\");\nvar Transform = __webpack_require__(/*! readable-stream */ \"readable-stream\").Transform;\nvar defined = __webpack_require__(/*! defined */ \"./node_modules/defined/index.js\");\n\nmodule.exports = Block;\ninherits(Block, Transform);\n\nfunction Block (size, opts) {\n    if (!(this instanceof Block)) return new Block(size, opts);\n    Transform.call(this);\n    if (!opts) opts = {};\n    if (typeof size === 'object') {\n        opts = size;\n        size = opts.size;\n    }\n    this.size = size || 512;\n    \n    if (opts.nopad) this._zeroPadding = false;\n    else this._zeroPadding = defined(opts.zeroPadding, true);\n    \n    this._buffered = [];\n    this._bufferedBytes = 0;\n}\n\nBlock.prototype._transform = function (buf, enc, next) {\n    this._bufferedBytes += buf.length;\n    this._buffered.push(buf);\n    \n    while (this._bufferedBytes >= this.size) {\n        var b = Buffer.concat(this._buffered);\n        this._bufferedBytes -= this.size;\n        this.push(b.slice(0, this.size));\n        this._buffered = [ b.slice(this.size, b.length) ];\n    }\n    next();\n};\n\nBlock.prototype._flush = function () {\n    if (this._bufferedBytes && this._zeroPadding) {\n        var zeroes = new Buffer(this.size - this._bufferedBytes);\n        zeroes.fill(0);\n        this._buffered.push(zeroes);\n        this.push(Buffer.concat(this._buffered));\n        this._buffered = null;\n    }\n    else if (this._bufferedBytes) {\n        this.push(Buffer.concat(this._buffered));\n        this._buffered = null;\n    }\n    this.push(null);\n};\n\n\n//# sourceURL=webpack:///./node_modules/block-stream2/index.js?");

/***/ }),

/***/ "./node_modules/defined/index.js":
/*!***************************************!*\
  !*** ./node_modules/defined/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\n    for (var i = 0; i < arguments.length; i++) {\n        if (arguments[i] !== undefined) return arguments[i];\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/defined/index.js?");

/***/ }),

/***/ "./node_modules/es6-error/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/es6-error/dist/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ExtendableError = (function (_Error) {\n  _inherits(ExtendableError, _Error);\n\n  function ExtendableError() {\n    var message = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n    _classCallCheck(this, ExtendableError);\n\n    _get(Object.getPrototypeOf(ExtendableError.prototype), 'constructor', this).call(this, message);\n\n    // extending Error is weird and does not propagate `message`\n    Object.defineProperty(this, 'message', {\n      enumerable: false,\n      value: message,\n      writable: true\n    });\n\n    Object.defineProperty(this, 'name', {\n      enumerable: false,\n      value: this.constructor.name,\n      writable: true\n    });\n\n    if (Error.hasOwnProperty('captureStackTrace')) {\n      Error.captureStackTrace(this, this.constructor);\n      return;\n    }\n\n    Object.defineProperty(this, 'stack', {\n      enumerable: false,\n      value: new Error(message).stack,\n      writable: true\n    });\n  }\n\n  return ExtendableError;\n})(Error);\n\nexports['default'] = ExtendableError;\nmodule.exports = exports['default'];\n\n//# sourceURL=webpack:///./node_modules/es6-error/dist/index.js?");

/***/ }),

/***/ "./node_modules/json-stream/lib/json-stream.js":
/*!*****************************************************!*\
  !*** ./node_modules/json-stream/lib/json-stream.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! util */ \"util\"),\n    TransformStream = __webpack_require__(/*! stream */ \"stream\").Transform;\n\nmodule.exports = function (options) {\n  return new JSONStream(options);\n};\n\nvar JSONStream = module.exports.JSONStream = function (options) {\n  options = options || {};\n  TransformStream.call(this, options);\n  this._writableState.objectMode = false;\n  this._readableState.objectMode = true;\n  this._async = options.async || false;\n};\nutil.inherits(JSONStream, TransformStream);\n\nJSONStream.prototype._transform = function (data, encoding, callback) {\n  if (!Buffer.isBuffer(data)) data = new Buffer(data);\n  if (this._buffer) {\n    data = Buffer.concat([this._buffer, data]);\n  }\n\n  var ptr = 0, start = 0;\n  while (++ptr <= data.length) {\n    if (data[ptr] === 10 || ptr === data.length) {\n      var line;\n      try {\n        line = JSON.parse(data.slice(start, ptr));\n      }\n      catch (ex) { }\n      if (line) {\n        this.push(line);\n        line = null;\n      }\n      if (data[ptr] === 10) start = ++ptr;\n    }\n  }\n\n  this._buffer = data.slice(start);\n  return this._async\n    ? void setImmediate(callback)\n    : void callback();\n};\n\n\n//# sourceURL=webpack:///./node_modules/json-stream/lib/json-stream.js?");

/***/ }),

/***/ "./node_modules/minio/dist/main/errors.js":
/*!************************************************!*\
  !*** ./node_modules/minio/dist/main/errors.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _es6Error = __webpack_require__(/*! es6-error */ \"./node_modules/es6-error/dist/index.js\");\n\nvar _es6Error2 = _interopRequireDefault(_es6Error);\n\n// AnonymousRequestError is generated for anonymous keys on specific\n// APIs. NOTE: PresignedURL generation always requires access keys.\n\nvar AnonymousRequestError = (function (_ExtendableError) {\n  _inherits(AnonymousRequestError, _ExtendableError);\n\n  function AnonymousRequestError(message) {\n    _classCallCheck(this, AnonymousRequestError);\n\n    _get(Object.getPrototypeOf(AnonymousRequestError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // InvalidArgumentError is generated for all invalid arguments.\n  return AnonymousRequestError;\n})(_es6Error2['default']);\n\nexports.AnonymousRequestError = AnonymousRequestError;\n\nvar InvalidArgumentError = (function (_ExtendableError2) {\n  _inherits(InvalidArgumentError, _ExtendableError2);\n\n  function InvalidArgumentError(message) {\n    _classCallCheck(this, InvalidArgumentError);\n\n    _get(Object.getPrototypeOf(InvalidArgumentError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // InvalidPortError is generated when a non integer value is provided\n  // for ports.\n  return InvalidArgumentError;\n})(_es6Error2['default']);\n\nexports.InvalidArgumentError = InvalidArgumentError;\n\nvar InvalidPortError = (function (_ExtendableError3) {\n  _inherits(InvalidPortError, _ExtendableError3);\n\n  function InvalidPortError(message) {\n    _classCallCheck(this, InvalidPortError);\n\n    _get(Object.getPrototypeOf(InvalidPortError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // InvalidEndpointError is generated when an invalid end point value is\n  // provided which does not follow domain standards.\n  return InvalidPortError;\n})(_es6Error2['default']);\n\nexports.InvalidPortError = InvalidPortError;\n\nvar InvalidEndpointError = (function (_ExtendableError4) {\n  _inherits(InvalidEndpointError, _ExtendableError4);\n\n  function InvalidEndpointError(message) {\n    _classCallCheck(this, InvalidEndpointError);\n\n    _get(Object.getPrototypeOf(InvalidEndpointError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // InvalidBucketNameError is generated when an invalid bucket name is\n  // provided which does not follow AWS S3 specifications.\n  // http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\n  return InvalidEndpointError;\n})(_es6Error2['default']);\n\nexports.InvalidEndpointError = InvalidEndpointError;\n\nvar InvalidBucketNameError = (function (_ExtendableError5) {\n  _inherits(InvalidBucketNameError, _ExtendableError5);\n\n  function InvalidBucketNameError(message) {\n    _classCallCheck(this, InvalidBucketNameError);\n\n    _get(Object.getPrototypeOf(InvalidBucketNameError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // InvalidObjectNameError is generated when an invalid object name is\n  // provided which does not follow AWS S3 specifications.\n  // http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html\n  return InvalidBucketNameError;\n})(_es6Error2['default']);\n\nexports.InvalidBucketNameError = InvalidBucketNameError;\n\nvar InvalidObjectNameError = (function (_ExtendableError6) {\n  _inherits(InvalidObjectNameError, _ExtendableError6);\n\n  function InvalidObjectNameError(message) {\n    _classCallCheck(this, InvalidObjectNameError);\n\n    _get(Object.getPrototypeOf(InvalidObjectNameError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // AccessKeyRequiredError generated by signature methods when access\n  // key is not found.\n  return InvalidObjectNameError;\n})(_es6Error2['default']);\n\nexports.InvalidObjectNameError = InvalidObjectNameError;\n\nvar AccessKeyRequiredError = (function (_ExtendableError7) {\n  _inherits(AccessKeyRequiredError, _ExtendableError7);\n\n  function AccessKeyRequiredError(message) {\n    _classCallCheck(this, AccessKeyRequiredError);\n\n    _get(Object.getPrototypeOf(AccessKeyRequiredError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // SecretKeyRequiredError generated by signature methods when secret\n  // key is not found.\n  return AccessKeyRequiredError;\n})(_es6Error2['default']);\n\nexports.AccessKeyRequiredError = AccessKeyRequiredError;\n\nvar SecretKeyRequiredError = (function (_ExtendableError8) {\n  _inherits(SecretKeyRequiredError, _ExtendableError8);\n\n  function SecretKeyRequiredError(message) {\n    _classCallCheck(this, SecretKeyRequiredError);\n\n    _get(Object.getPrototypeOf(SecretKeyRequiredError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // ExpiresParamError generated when expires parameter value is not\n  // well within stipulated limits.\n  return SecretKeyRequiredError;\n})(_es6Error2['default']);\n\nexports.SecretKeyRequiredError = SecretKeyRequiredError;\n\nvar ExpiresParamError = (function (_ExtendableError9) {\n  _inherits(ExpiresParamError, _ExtendableError9);\n\n  function ExpiresParamError(message) {\n    _classCallCheck(this, ExpiresParamError);\n\n    _get(Object.getPrototypeOf(ExpiresParamError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // InvalidDateError generated when invalid date is found.\n  return ExpiresParamError;\n})(_es6Error2['default']);\n\nexports.ExpiresParamError = ExpiresParamError;\n\nvar InvalidDateError = (function (_ExtendableError10) {\n  _inherits(InvalidDateError, _ExtendableError10);\n\n  function InvalidDateError(message) {\n    _classCallCheck(this, InvalidDateError);\n\n    _get(Object.getPrototypeOf(InvalidDateError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // InvalidPrefixError generated when object prefix provided is invalid\n  // or does not conform to AWS S3 object key restrictions.\n  return InvalidDateError;\n})(_es6Error2['default']);\n\nexports.InvalidDateError = InvalidDateError;\n\nvar InvalidPrefixError = (function (_ExtendableError11) {\n  _inherits(InvalidPrefixError, _ExtendableError11);\n\n  function InvalidPrefixError(message) {\n    _classCallCheck(this, InvalidPrefixError);\n\n    _get(Object.getPrototypeOf(InvalidPrefixError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // InvalidBucketPolicyError generated when the given bucket policy is invalid.\n  return InvalidPrefixError;\n})(_es6Error2['default']);\n\nexports.InvalidPrefixError = InvalidPrefixError;\n\nvar InvalidBucketPolicyError = (function (_ExtendableError12) {\n  _inherits(InvalidBucketPolicyError, _ExtendableError12);\n\n  function InvalidBucketPolicyError(message) {\n    _classCallCheck(this, InvalidBucketPolicyError);\n\n    _get(Object.getPrototypeOf(InvalidBucketPolicyError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // IncorrectSizeError generated when total data read mismatches with\n  // the input size.\n  return InvalidBucketPolicyError;\n})(_es6Error2['default']);\n\nexports.InvalidBucketPolicyError = InvalidBucketPolicyError;\n\nvar IncorrectSizeError = (function (_ExtendableError13) {\n  _inherits(IncorrectSizeError, _ExtendableError13);\n\n  function IncorrectSizeError(message) {\n    _classCallCheck(this, IncorrectSizeError);\n\n    _get(Object.getPrototypeOf(IncorrectSizeError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // InvalidXMLError generated when an unknown XML is found.\n  return IncorrectSizeError;\n})(_es6Error2['default']);\n\nexports.IncorrectSizeError = IncorrectSizeError;\n\nvar InvalidXMLError = (function (_ExtendableError14) {\n  _inherits(InvalidXMLError, _ExtendableError14);\n\n  function InvalidXMLError(message) {\n    _classCallCheck(this, InvalidXMLError);\n\n    _get(Object.getPrototypeOf(InvalidXMLError.prototype), 'constructor', this).call(this, message);\n  }\n\n  // S3Error is generated for errors returned from S3 server.\n  // see getErrorTransformer for details\n  return InvalidXMLError;\n})(_es6Error2['default']);\n\nexports.InvalidXMLError = InvalidXMLError;\n\nvar S3Error = (function (_ExtendableError15) {\n  _inherits(S3Error, _ExtendableError15);\n\n  function S3Error(message) {\n    _classCallCheck(this, S3Error);\n\n    _get(Object.getPrototypeOf(S3Error.prototype), 'constructor', this).call(this, message);\n  }\n\n  return S3Error;\n})(_es6Error2['default']);\n\nexports.S3Error = S3Error;\n//# sourceMappingURL=errors.js.map\n\n\n//# sourceURL=webpack:///./node_modules/minio/dist/main/errors.js?");

/***/ }),

/***/ "./node_modules/minio/dist/main/helpers.js":
/*!*************************************************!*\
  !*** ./node_modules/minio/dist/main/helpers.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _slice = Array.prototype.slice;\nexports.promisify = promisify;\nexports.uriEscape = uriEscape;\nexports.uriResourceEscape = uriResourceEscape;\nexports.getScope = getScope;\nexports.isAmazonEndpoint = isAmazonEndpoint;\nexports.isVirtualHostStyle = isVirtualHostStyle;\nexports.isValidIP = isValidIP;\nexports.isValidEndpoint = isValidEndpoint;\nexports.isValidDomain = isValidDomain;\nexports.probeContentType = probeContentType;\nexports.isValidPort = isValidPort;\nexports.isValidBucketName = isValidBucketName;\nexports.isValidObjectName = isValidObjectName;\nexports.isValidPrefix = isValidPrefix;\nexports.isNumber = isNumber;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isReadableStream = isReadableStream;\nexports.isBoolean = isBoolean;\nexports.isArray = isArray;\nexports.makeDateLong = makeDateLong;\nexports.makeDateShort = makeDateShort;\nexports.pipesetup = pipesetup;\nexports.readableStream = readableStream;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _stream = __webpack_require__(/*! stream */ \"stream\");\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nvar _mimeTypes = __webpack_require__(/*! mime-types */ \"mime-types\");\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\n// Returns a wrapper function that will promisify a given callback function.\n// It will preserve 'this'.\n\nfunction promisify(fn) {\n  return function () {\n    var _this = this;\n\n    // If the last argument is a function, assume its the callback.\n    var callback = arguments[arguments.length - 1];\n\n    // If the callback is given, don't promisify, just pass straight in.\n    if (typeof callback === 'function') return fn.apply(this, arguments);\n\n    // Otherwise, create a new set of arguments, and wrap\n    // it in a promise.\n    var args = [].concat(_slice.call(arguments));\n\n    return new Promise(function (resolve, reject) {\n      // Add the callback function.\n      args.push(function (err, value) {\n        if (err) return reject(err);\n\n        resolve(value);\n      });\n\n      // Call the function with our special adaptor callback added.\n      fn.apply(_this, args);\n    });\n  };\n}\n\n// All characters in string which are NOT unreserved should be percent encoded.\n// Unreserved characers are : ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n// Reference https://tools.ietf.org/html/rfc3986#section-2.2\n\nfunction uriEscape(string) {\n  return string.split('').reduce(function (acc, elem) {\n    var buf = new Buffer(elem);\n    if (buf.length === 1) {\n      // length 1 indicates that elem is not a unicode character.\n      // Check if it is an unreserved characer.\n      if ('A' <= elem && elem <= 'Z' || 'a' <= elem && elem <= 'z' || '0' <= elem && elem <= '9' || elem === '_' || elem === '.' || elem === '~' || elem === '-') {\n        // Unreserved characer should not be encoded.\n        acc = acc + elem;\n        return acc;\n      }\n    }\n    // elem needs encoding - i.e elem should be encoded if it's not unreserved\n    // character or if it's a unicode character.\n    for (var i = 0; i < buf.length; i++) {\n      acc = acc + \"%\" + buf[i].toString(16).toUpperCase();\n    }\n    return acc;\n  }, '');\n}\n\nfunction uriResourceEscape(string) {\n  return uriEscape(string).replace(/%2F/g, '/');\n}\n\nfunction getScope(region, date) {\n  return makeDateShort(date) + '/' + region + '/s3/aws4_request';\n}\n\n// isAmazonEndpoint - true if endpoint is 's3.amazonaws.com' or 's3.cn-north-1.amazonaws.com.cn'\n\nfunction isAmazonEndpoint(endpoint) {\n  return endpoint === 's3.amazonaws.com' || endpoint === 's3.cn-north-1.amazonaws.com.cn';\n}\n\n// isVirtualHostStyle - verify if bucket name is support with virtual\n// hosts. bucketNames with periods should be always treated as path\n// style if the protocol is 'https:', this is due to SSL wildcard\n// limitation. For all other buckets and Amazon S3 endpoint we will\n// default to virtual host style.\n\nfunction isVirtualHostStyle(endpoint, protocol, bucket) {\n  if (protocol === 'https:' && bucket.indexOf('.') > -1) {\n    return false;\n  }\n  return isAmazonEndpoint(endpoint);\n}\n\nvar ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\n\nfunction isValidIP(ip) {\n  return ipv4Regex.test(ip);\n}\n\n// isValidEndpoint - true if endpoint is valid domain.\n\nfunction isValidEndpoint(endpoint) {\n  if (!isValidDomain(endpoint) && !isValidIP(endpoint)) {\n    return false;\n  }\n  // Return true.\n  return true;\n}\n\n// isValidDomain - true if input host is a valid domain.\n\nfunction isValidDomain(host) {\n  if (!isString(host)) return false;\n  // See RFC 1035, RFC 3696.\n  if (host.length === 0 || host.length > 255) {\n    return false;\n  }\n  // Host cannot start or end with a '-'\n  if (host[0] === '-' || host.substr(-1) === '-') {\n    return false;\n  }\n  // Host cannot start or end with a '_'\n  if (host[0] === '_' || host.substr(-1) === '_') {\n    return false;\n  }\n  // Host cannot start or end with a '.'\n  if (host[0] === '.' || host.substr(-1) === '.') {\n    return false;\n  }\n  var alphaNumerics = '`~!@#$%^&*()+={}[]|\\\\\"\\';:><?/'.split('');\n  // All non alphanumeric characters are invalid.\n  for (var i in alphaNumerics) {\n    if (host.indexOf(alphaNumerics[i]) > -1) {\n      return false;\n    }\n  }\n  // No need to regexp match, since the list is non-exhaustive.\n  // We let it be valid and fail later.\n  return true;\n}\n\n// Probes contentType using file extensions.\n// For example: probeContentType('file.png') returns 'image/png'.\n\nfunction probeContentType(path) {\n  var contentType = _mimeTypes2['default'].lookup(path);\n  if (!contentType) {\n    contentType = 'application/octet-stream';\n  }\n  return contentType;\n}\n\n// isValidPort - is input port valid.\n\nfunction isValidPort(port) {\n  // verify if port is a number.\n  if (!isNumber(port)) return false;\n  // port cannot be negative.\n  if (port < 0) return false;\n  // port '0' is valid and special case return true.\n  if (port === 0) return true;\n  var min_port = 1;\n  var max_port = 65535;\n  // Verify if port is in range.\n  return port >= min_port && port <= max_port;\n}\n\nfunction isValidBucketName(bucket) {\n  if (!isString(bucket)) return false;\n\n  // bucket length should be less than and no more than 63\n  // characters long.\n  if (bucket.length < 3 || bucket.length > 63) {\n    return false;\n  }\n  // bucket with successive periods is invalid.\n  if (bucket.indexOf('..') > -1) {\n    return false;\n  }\n  // bucket cannot have ip address style.\n  if (bucket.match(/[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/)) {\n    return false;\n  }\n  // bucket should begin with alphabet/number and end with alphabet/number,\n  // with alphabet/number/.- in the middle.\n  if (bucket.match(/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/)) {\n    return true;\n  }\n  return false;\n}\n\n// check if objectName is a valid object name\n\nfunction isValidObjectName(objectName) {\n  if (!isValidPrefix(objectName)) return false;\n  if (objectName.length === 0) return false;\n  return true;\n}\n\n// check if prefix is valid\n\nfunction isValidPrefix(prefix) {\n  if (!isString(prefix)) return false;\n  if (prefix.length > 1024) return false;\n  return true;\n}\n\n// check if typeof arg number\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\n// check if typeof arg function\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\n// check if typeof arg string\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\n// check if typeof arg object\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\n// check if object is readable stream\n\nfunction isReadableStream(arg) {\n  return isObject(arg) && isFunction(arg._read);\n}\n\n// check if arg is boolean\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\n\n// check if arg is array\n\nfunction isArray(arg) {\n  return Array.isArray(arg);\n}\n\n// Create a Date string with format:\n// 'YYYYMMDDTHHmmss' + Z\n\nfunction makeDateLong(date) {\n  date = date || new Date();\n\n  // Gives format like: '2017-08-07T16:28:59.889Z'\n  date = date.toISOString();\n\n  return date.substr(0, 4) + date.substr(5, 2) + date.substr(8, 5) + date.substr(14, 2) + date.substr(17, 2) + 'Z';\n}\n\n// Create a Date string with format:\n// 'YYYYMMDD'\n\nfunction makeDateShort(date) {\n  date = date || new Date();\n\n  // Gives format like: '2017-08-07T16:28:59.889Z'\n  date = date.toISOString();\n\n  return date.substr(0, 4) + date.substr(5, 2) + date.substr(8, 2);\n}\n\n// pipesetup sets up pipe() from left to right os streams array\n// pipesetup will also make sure that error emitted at any of the upstream Stream\n// will be emitted at the last stream. This makes error handling simple\n\nfunction pipesetup() {\n  for (var _len = arguments.length, streams = Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  return streams.reduce(function (src, dst) {\n    src.on('error', function (err) {\n      return dst.emit('error', err);\n    });\n    return src.pipe(dst);\n  });\n}\n\n// return a Readable stream that emits data\n\nfunction readableStream(data) {\n  var s = new _stream2['default'].Readable();\n  s._read = function () {};\n  s.push(data);\n  s.push(null);\n  return s;\n}\n//# sourceMappingURL=helpers.js.map\n\n\n//# sourceURL=webpack:///./node_modules/minio/dist/main/helpers.js?");

/***/ }),

/***/ "./node_modules/minio/dist/main/minio.js":
/*!***********************************************!*\
  !*** ./node_modules/minio/dist/main/minio.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopExportWildcard(obj, defaults) { var newObj = defaults({}, obj); delete newObj['default']; return newObj; }\n\nfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nvar _http = __webpack_require__(/*! http */ \"http\");\n\nvar _http2 = _interopRequireDefault(_http);\n\nvar _https = __webpack_require__(/*! https */ \"https\");\n\nvar _https2 = _interopRequireDefault(_https);\n\nvar _stream = __webpack_require__(/*! stream */ \"stream\");\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nvar _blockStream2 = __webpack_require__(/*! block-stream2 */ \"./node_modules/block-stream2/index.js\");\n\nvar _blockStream22 = _interopRequireDefault(_blockStream2);\n\nvar _xml = __webpack_require__(/*! xml */ \"./node_modules/xml/lib/xml.js\");\n\nvar _xml2 = _interopRequireDefault(_xml);\n\nvar _xml2js = __webpack_require__(/*! xml2js */ \"./node_modules/xml2js/lib/xml2js.js\");\n\nvar _xml2js2 = _interopRequireDefault(_xml2js);\n\nvar _async = __webpack_require__(/*! async */ \"async\");\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _querystring = __webpack_require__(/*! querystring */ \"querystring\");\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _mkdirp = __webpack_require__(/*! mkdirp */ \"mkdirp\");\n\nvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\nvar _path = __webpack_require__(/*! path */ \"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _lodash = __webpack_require__(/*! lodash */ \"lodash\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _helpersJs = __webpack_require__(/*! ./helpers.js */ \"./node_modules/minio/dist/main/helpers.js\");\n\nvar _signingJs = __webpack_require__(/*! ./signing.js */ \"./node_modules/minio/dist/main/signing.js\");\n\nvar _objectUploader = __webpack_require__(/*! ./object-uploader */ \"./node_modules/minio/dist/main/object-uploader.js\");\n\nvar _objectUploader2 = _interopRequireDefault(_objectUploader);\n\nvar _transformers = __webpack_require__(/*! ./transformers */ \"./node_modules/minio/dist/main/transformers.js\");\n\nvar transformers = _interopRequireWildcard(_transformers);\n\nvar _errorsJs = __webpack_require__(/*! ./errors.js */ \"./node_modules/minio/dist/main/errors.js\");\n\nvar errors = _interopRequireWildcard(_errorsJs);\n\nvar _s3EndpointsJs = __webpack_require__(/*! ./s3-endpoints.js */ \"./node_modules/minio/dist/main/s3-endpoints.js\");\n\nvar _notification = __webpack_require__(/*! ./notification */ \"./node_modules/minio/dist/main/notification.js\");\n\n__webpack_require__(/*! source-map-support */ \"source-map-support\").install();\n\nvar Package = __webpack_require__(/*! ../../package.json */ \"./node_modules/minio/package.json\");\n\nvar Client = (function () {\n  function Client(params) {\n    _classCallCheck(this, Client);\n\n    // Default values if not specified.\n    if (typeof params.secure === 'undefined') params.secure = true;\n    if (!params.port) params.port = 0;\n    // Validate input params.\n    if (!(0, _helpersJs.isValidEndpoint)(params.endPoint)) {\n      throw new errors.InvalidEndpointError('Invalid endPoint : ' + params.endPoint);\n    }\n    if (!(0, _helpersJs.isValidPort)(params.port)) {\n      throw new errors.InvalidArgumentError('Invalid port : ' + params.port);\n    }\n    if (!(0, _helpersJs.isBoolean)(params.secure)) {\n      throw new errors.InvalidArgumentError('Invalid secure flag type : ' + params.secure + ', expected to be of type \"boolean\"');\n    }\n\n    // Validate region only if its set.\n    if (params.region) {\n      if (!(0, _helpersJs.isString)(params.region)) {\n        throw new errors.InvalidArgumentError('Invalid region : ' + params.region);\n      }\n    }\n\n    var host = params.endPoint.toLowerCase();\n    var port = params.port;\n    var protocol = '';\n    var transport;\n    // Validate if configuration is not using SSL\n    // for constructing relevant endpoints.\n    if (params.secure === false) {\n      transport = _http2['default'];\n      protocol = 'http:';\n      if (port === 0) {\n        port = 80;\n      }\n    } else {\n      // Defaults to secure.\n      transport = _https2['default'];\n      protocol = 'https:';\n      if (port === 0) {\n        port = 443;\n      }\n    }\n\n    // if custom transport is set, use it.\n    if (params.transport) {\n      if (!(0, _helpersJs.isObject)(params.transport)) {\n        throw new errors.InvalidArgumentError('Invalid transport type : ${params.transport}, expected to be type \"object\"');\n      }\n      transport = params.transport;\n    }\n\n    // User Agent should always following the below style.\n    // Please open an issue to discuss any new changes here.\n    //\n    //       Minio (OS; ARCH) LIB/VER APP/VER\n    //\n    var libraryComments = '(' + process.platform + '; ' + process.arch + ')';\n    var libraryAgent = 'Minio ' + libraryComments + ' minio-js/' + Package.version;\n    // User agent block ends.\n\n    this.transport = transport;\n    this.host = host;\n    this.port = port;\n    this.protocol = protocol;\n    this.accessKey = params.accessKey;\n    this.secretKey = params.secretKey;\n    this.sessionToken = params.sessionToken;\n    this.userAgent = '' + libraryAgent;\n\n    if (!this.accessKey) this.accessKey = '';\n    if (!this.secretKey) this.secretKey = '';\n    this.anonymous = !this.accessKey || !this.secretKey;\n\n    this.regionMap = {};\n    if (params.region) {\n      this.region = params.region;\n    }\n\n    this.minimumPartSize = 5 * 1024 * 1024;\n    this.maximumPartSize = 5 * 1024 * 1024 * 1024;\n    this.maxObjectSize = 5 * 1024 * 1024 * 1024 * 1024;\n    // SHA256 is enabled only for authenticated http requests. If the request is authenticated\n    // and the connection is https we use x-amz-content-sha256=UNSIGNED-PAYLOAD\n    // header for signature calculation.\n    this.enableSHA256 = !this.anonymous && !params.secure;\n\n    this.reqOptions = {};\n  }\n\n  // Promisify various public-facing APIs on the Client module.\n\n  // Sets the supported request options.\n\n  _createClass(Client, [{\n    key: 'setRequestOptions',\n    value: function setRequestOptions(options) {\n      if (!(0, _helpersJs.isObject)(options)) {\n        throw new TypeError('request options should be of type \"object\"');\n      }\n      this.reqOptions = _lodash2['default'].pick(options, ['agent', 'ca', 'cert', 'ciphers', 'clientCertEngine', 'crl', 'dhparam', 'ecdhCurve', 'honorCipherOrder', 'key', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureOptions', 'secureProtocol', 'servername', 'sessionIdContext']);\n    }\n\n    // returns *options* object that can be used with http.request()\n    // Takes care of constructing virtual-host-style or path-style hostname\n  }, {\n    key: 'getRequestOptions',\n    value: function getRequestOptions(opts) {\n      var method = opts.method;\n      var region = opts.region;\n      var bucketName = opts.bucketName;\n      var objectName = opts.objectName;\n      var headers = opts.headers;\n      var query = opts.query;\n\n      var reqOptions = { method: method };\n      reqOptions.headers = {};\n\n      // Verify if virtual host supported.\n      var virtualHostStyle;\n      if (bucketName) {\n        virtualHostStyle = (0, _helpersJs.isVirtualHostStyle)(this.host, this.protocol, bucketName);\n      }\n\n      if (this.port) reqOptions.port = this.port;\n      reqOptions.protocol = this.protocol;\n\n      if (objectName) {\n        objectName = '' + (0, _helpersJs.uriResourceEscape)(objectName);\n      }\n\n      reqOptions.path = '/';\n\n      // Save host.\n      reqOptions.host = this.host;\n      // For Amazon S3 endpoint, get endpoint based on region.\n      if ((0, _helpersJs.isAmazonEndpoint)(reqOptions.host)) {\n        reqOptions.host = (0, _s3EndpointsJs.getS3Endpoint)(region);\n      }\n\n      if (virtualHostStyle && !opts.pathStyle) {\n        // For all hosts which support virtual host style, `bucketName`\n        // is part of the hostname in the following format:\n        //\n        //  var host = 'bucketName.example.com'\n        //\n        if (bucketName) reqOptions.host = bucketName + '.' + reqOptions.host;\n        if (objectName) reqOptions.path = '/' + objectName;\n      } else {\n        // For all S3 compatible storage services we will fallback to\n        // path style requests, where `bucketName` is part of the URI\n        // path.\n        if (bucketName) reqOptions.path = '/' + bucketName;\n        if (objectName) reqOptions.path = '/' + bucketName + '/' + objectName;\n      }\n\n      if (query) reqOptions.path += '?' + query;\n      reqOptions.headers.host = reqOptions.host;\n      if (reqOptions.protocol === 'http:' && reqOptions.port !== 80 || reqOptions.protocol === 'https:' && reqOptions.port !== 443) {\n        reqOptions.headers.host = reqOptions.host + ':' + reqOptions.port;\n      }\n      reqOptions.headers['user-agent'] = this.userAgent;\n      if (headers) {\n        // have all header keys in lower case - to make signing easy\n        _lodash2['default'].map(headers, function (v, k) {\n          return reqOptions.headers[k.toLowerCase()] = v;\n        });\n      }\n\n      // Use any request option specified in minioClient.setRequestOptions()\n      reqOptions = Object.assign({}, this.reqOptions, reqOptions);\n\n      return reqOptions;\n    }\n\n    // Set application specific information.\n    //\n    // Generates User-Agent in the following style.\n    //\n    //       Minio (OS; ARCH) LIB/VER APP/VER\n    //\n    // __Arguments__\n    // * `appName` _string_ - Application name.\n    // * `appVersion` _string_ - Application version.\n  }, {\n    key: 'setAppInfo',\n    value: function setAppInfo(appName, appVersion) {\n      if (!(0, _helpersJs.isString)(appName)) {\n        throw new TypeError('Invalid appName: ' + appName);\n      }\n      if (appName.trim() === '') {\n        throw new errors.InvalidArgumentError('Input appName cannot be empty.');\n      }\n      if (!(0, _helpersJs.isString)(appVersion)) {\n        throw new TypeError('Invalid appName: ' + appVersion);\n      }\n      if (appVersion.trim() === '') {\n        throw new errors.InvalidArgumentError('Input appVersion cannot be empty.');\n      }\n      this.userAgent = this.userAgent + ' ' + appName + '/' + appVersion;\n    }\n\n    // partSize will be atleast minimumPartSize or a multiple of minimumPartSize\n    // for size <= 50GiB partSize is always 5MiB (10000*5MiB = 50GiB)\n    // for size > 50GiB partSize will be a multiple of 5MiB\n    // for size = 5TiB partSize will be 525MiB\n  }, {\n    key: 'calculatePartSize',\n    value: function calculatePartSize(size) {\n      if (!(0, _helpersJs.isNumber)(size)) {\n        throw new TypeError('size should be of type \"number\"');\n      }\n      if (size > this.maxObjectSize) {\n        throw new TypeError('size should not be more than ' + this.maxObjectSize);\n      }\n      var partSize = Math.ceil(size / 10000);\n      partSize = Math.ceil(partSize / this.minimumPartSize) * this.minimumPartSize;\n      return partSize;\n    }\n\n    // log the request, response, error\n  }, {\n    key: 'logHTTP',\n    value: function logHTTP(reqOptions, response, err) {\n      var _this = this;\n\n      // if no logstreamer available return.\n      if (!this.logStream) return;\n      if (!(0, _helpersJs.isObject)(reqOptions)) {\n        throw new TypeError('reqOptions should be of type \"object\"');\n      }\n      if (response && !(0, _helpersJs.isReadableStream)(response)) {\n        throw new TypeError('response should be of type \"Stream\"');\n      }\n      if (err && !(err instanceof Error)) {\n        throw new TypeError('err should be of type \"Error\"');\n      }\n      var logHeaders = function logHeaders(headers) {\n        _lodash2['default'].forEach(headers, function (v, k) {\n          if (k == 'authorization') {\n            var redacter = new RegExp('Signature=([0-9a-f]+)');\n            v = v.replace(redacter, 'Signature=**REDACTED**');\n          }\n          _this.logStream.write(k + ': ' + v + '\\n');\n        });\n        _this.logStream.write('\\n');\n      };\n      this.logStream.write('REQUEST: ' + reqOptions.method + ' ' + reqOptions.path + '\\n');\n      logHeaders(reqOptions.headers);\n      if (response) {\n        this.logStream.write('RESPONSE: ' + response.statusCode + '\\n');\n        logHeaders(response.headers);\n      }\n      if (err) {\n        this.logStream.write('ERROR BODY:\\n');\n        var errJSON = JSON.stringify(err, null, '\\t');\n        this.logStream.write(errJSON + '\\n');\n      }\n    }\n\n    // Enable tracing\n  }, {\n    key: 'traceOn',\n    value: function traceOn(stream) {\n      if (!stream) stream = process.stdout;\n      this.logStream = stream;\n    }\n\n    // Disable tracing\n  }, {\n    key: 'traceOff',\n    value: function traceOff() {\n      this.logStream = null;\n    }\n\n    // makeRequest is the primitive used by the apis for making S3 requests.\n    // payload can be empty string in case of no payload.\n    // statusCode is the expected statusCode. If response.statusCode does not match\n    // we parse the XML error and call the callback with the error message.\n    // A valid region is passed by the calls - listBuckets, makeBucket and\n    // getBucketRegion.\n  }, {\n    key: 'makeRequest',\n    value: function makeRequest(options, payload, statusCode, region, returnResponse, cb) {\n      if (!(0, _helpersJs.isObject)(options)) {\n        throw new TypeError('options should be of type \"object\"');\n      }\n      if (!(0, _helpersJs.isString)(payload) && !(0, _helpersJs.isObject)(payload)) {\n        // Buffer is of type 'object'\n        throw new TypeError('payload should be of type \"string\" or \"Buffer\"');\n      }\n      if (!(0, _helpersJs.isNumber)(statusCode)) {\n        throw new TypeError('statusCode should be of type \"number\"');\n      }\n      if (!(0, _helpersJs.isString)(region)) {\n        throw new TypeError('region should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isBoolean)(returnResponse)) {\n        throw new TypeError('returnResponse should be of type \"boolean\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      if (!options.headers) options.headers = {};\n      if (options.method === 'POST' || options.method === 'PUT' || options.method === 'DELETE') {\n        options.headers['content-length'] = payload.length;\n      }\n      var sha256sum = '';\n      if (this.enableSHA256) sha256sum = _crypto2['default'].createHash('sha256').update(payload).digest('hex');\n      var stream = (0, _helpersJs.readableStream)(payload);\n      this.makeRequestStream(options, stream, sha256sum, statusCode, region, returnResponse, cb);\n    }\n\n    // makeRequestStream will be used directly instead of makeRequest in case the payload\n    // is available as a stream. for ex. putObject\n  }, {\n    key: 'makeRequestStream',\n    value: function makeRequestStream(options, stream, sha256sum, statusCode, region, returnResponse, cb) {\n      var _this2 = this;\n\n      if (!(0, _helpersJs.isObject)(options)) {\n        throw new TypeError('options should be of type \"object\"');\n      }\n      if (!(0, _helpersJs.isReadableStream)(stream)) {\n        throw new errors.InvalidArgumentError('stream should be a readable Stream');\n      }\n      if (!(0, _helpersJs.isString)(sha256sum)) {\n        throw new TypeError('sha256sum should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isNumber)(statusCode)) {\n        throw new TypeError('statusCode should be of type \"number\"');\n      }\n      if (!(0, _helpersJs.isString)(region)) {\n        throw new TypeError('region should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isBoolean)(returnResponse)) {\n        throw new TypeError('returnResponse should be of type \"boolean\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n\n      // sha256sum will be empty for anonymous or https requests\n      if (!this.enableSHA256 && sha256sum.length !== 0) {\n        throw new errors.InvalidArgumentError('sha256sum expected to be empty for anonymous or https requests');\n      }\n      // sha256sum should be valid for non-anonymous http requests.\n      if (this.enableSHA256 && sha256sum.length !== 64) {\n        throw new errors.InvalidArgumentError('Invalid sha256sum : ' + sha256sum);\n      }\n\n      var _makeRequest = function _makeRequest(e, region) {\n        if (e) return cb(e);\n        options.region = region;\n        var reqOptions = _this2.getRequestOptions(options);\n        if (!_this2.anonymous) {\n          // For non-anonymous https requests sha256sum is 'UNSIGNED-PAYLOAD' for signature calculation.\n          if (!_this2.enableSHA256) sha256sum = 'UNSIGNED-PAYLOAD';\n\n          var date = new Date();\n\n          reqOptions.headers['x-amz-date'] = (0, _helpersJs.makeDateLong)(date);\n          reqOptions.headers['x-amz-content-sha256'] = sha256sum;\n          if (_this2.sessionToken) {\n            reqOptions.headers['x-amz-security-token'] = _this2.sessionToken;\n          }\n\n          var authorization = (0, _signingJs.signV4)(reqOptions, _this2.accessKey, _this2.secretKey, region, date);\n          reqOptions.headers.authorization = authorization;\n        }\n        var req = _this2.transport.request(reqOptions, function (response) {\n          if (statusCode !== response.statusCode) {\n            // For an incorrect region, S3 server always sends back 400.\n            // But we will do cache invalidation for all errors so that,\n            // in future, if AWS S3 decides to send a different status code or\n            // XML error code we will still work fine.\n            delete _this2.regionMap[options.bucketName];\n            var errorTransformer = transformers.getErrorTransformer(response);\n            (0, _helpersJs.pipesetup)(response, errorTransformer).on('error', function (e) {\n              _this2.logHTTP(reqOptions, response, e);\n              cb(e);\n            });\n            return;\n          }\n          _this2.logHTTP(reqOptions, response);\n          if (returnResponse) return cb(null, response);\n          // We drain the socket so that the connection gets closed. Note that this\n          // is not expensive as the socket will not have any data.\n          response.on('data', function () {});\n          cb(null);\n        });\n        var pipe = (0, _helpersJs.pipesetup)(stream, req);\n        pipe.on('error', function (e) {\n          _this2.logHTTP(reqOptions, null, e);\n          cb(e);\n        });\n      };\n      if (region) return _makeRequest(null, region);\n      this.getBucketRegion(options.bucketName, _makeRequest);\n    }\n\n    // gets the region of the bucket\n  }, {\n    key: 'getBucketRegion',\n    value: function getBucketRegion(bucketName, cb) {\n      var _this3 = this;\n\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name : ' + bucketName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('cb should be of type \"function\"');\n      }\n\n      // Region is set with constructor, return the region right here.\n      if (this.region) return cb(null, this.region);\n\n      if (this.regionMap[bucketName]) return cb(null, this.regionMap[bucketName]);\n      var extractRegion = function extractRegion(response) {\n        var transformer = transformers.getBucketRegionTransformer();\n        var region = 'us-east-1';\n        (0, _helpersJs.pipesetup)(response, transformer).on('error', cb).on('data', function (data) {\n          if (data) region = data;\n        }).on('end', function () {\n          _this3.regionMap[bucketName] = region;\n          cb(null, region);\n        });\n      };\n\n      var method = 'GET';\n      var query = 'location';\n\n      // `getBucketLocation` behaves differently in following ways for\n      // different environments.\n      //\n      // - For nodejs env we default to path style requests.\n      // - For browser env path style requests on buckets yields CORS\n      //   error. To circumvent this problem we make a virtual host\n      //   style request signed with 'us-east-1'. This request fails\n      //   with an error 'AuthorizationHeaderMalformed', additionally\n      //   the error XML also provides Region of the bucket. To validate\n      //   this region is proper we retry the same request with the newly\n      //   obtained region.\n      var pathStyle = typeof window === 'undefined';\n      this.makeRequest({ method: method, bucketName: bucketName, query: query, pathStyle: pathStyle }, '', 200, 'us-east-1', true, function (e, response) {\n        if (e) {\n          if (e.name === 'AuthorizationHeaderMalformed') {\n            var region = e.Region;\n            if (!region) return cb(e);\n            _this3.makeRequest({ method: method, bucketName: bucketName, query: query }, '', 200, region, true, function (e, response) {\n              if (e) return cb(e);\n              extractRegion(response);\n            });\n            return;\n          }\n          return cb(e);\n        }\n        extractRegion(response);\n      });\n    }\n\n    // Creates the bucket `bucketName`.\n    //\n    // __Arguments__\n    // * `bucketName` _string_ - Name of the bucket\n    // * `region` _string_ - region valid values are _us-west-1_, _us-west-2_,  _eu-west-1_, _eu-central-1_, _ap-southeast-1_, _ap-northeast-1_, _ap-southeast-2_, _sa-east-1_.\n    // * `callback(err)` _function_ - callback function with `err` as the error argument. `err` is null if the bucket is successfully created.\n  }, {\n    key: 'makeBucket',\n    value: function makeBucket(bucketName, region, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n\n      if ((0, _helpersJs.isFunction)(region)) {\n        cb = region;\n        region = '';\n      }\n\n      if (!(0, _helpersJs.isString)(region)) {\n        throw new TypeError('region should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n\n      var payload = '';\n\n      // Region already set in constructor, validate if\n      // caller requested bucket location is same.\n      if (region && this.region) {\n        if (region !== this.region) {\n          throw new errors.InvalidArgumentError('Configured region ' + this.region + ', requested ' + region);\n        }\n      }\n\n      // sending makeBucket request with XML containing 'us-east-1' fails. For\n      // default region server expects the request without body\n      if (region && region !== 'us-east-1') {\n        var createBucketConfiguration = [];\n        createBucketConfiguration.push({\n          _attr: {\n            xmlns: 'http://s3.amazonaws.com/doc/2006-03-01/'\n          }\n        });\n        createBucketConfiguration.push({\n          LocationConstraint: region\n        });\n        var payloadObject = {\n          CreateBucketConfiguration: createBucketConfiguration\n        };\n        payload = (0, _xml2['default'])(payloadObject);\n      }\n      var method = 'PUT';\n      var headers = {};\n      if (!region) region = 'us-east-1';\n      this.makeRequest({ method: method, bucketName: bucketName, headers: headers }, payload, 200, region, false, cb);\n    }\n\n    // List of buckets created.\n    //\n    // __Arguments__\n    // * `callback(err, buckets)` _function_ - callback function with error as the first argument. `buckets` is an array of bucket information\n    //\n    // `buckets` array element:\n    // * `bucket.name` _string_ : bucket name\n    // * `bucket.creationDate` _Date_: date when bucket was created\n  }, {\n    key: 'listBuckets',\n    value: function listBuckets(cb) {\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      var method = 'GET';\n      this.makeRequest({ method: method }, '', 200, 'us-east-1', true, function (e, response) {\n        if (e) return cb(e);\n        var transformer = transformers.getListBucketTransformer();\n        var buckets;\n        (0, _helpersJs.pipesetup)(response, transformer).on('data', function (result) {\n          return buckets = result;\n        }).on('error', function (e) {\n          return cb(e);\n        }).on('end', function () {\n          return cb(null, buckets);\n        });\n      });\n    }\n\n    // Returns a stream that emits objects that are partially uploaded.\n    //\n    // __Arguments__\n    // * `bucketname` _string_: name of the bucket\n    // * `prefix` _string_: prefix of the object names that are partially uploaded (optional, default `''`)\n    // * `recursive` _bool_: directory style listing when false, recursive listing when true (optional, default `false`)\n    //\n    // __Return Value__\n    // * `stream` _Stream_ : emits objects of the format:\n    //   * `object.key` _string_: name of the object\n    //   * `object.uploadId` _string_: upload ID of the object\n    //   * `object.size` _Integer_: size of the partially uploaded object\n  }, {\n    key: 'listIncompleteUploads',\n    value: function listIncompleteUploads(bucket, prefix, recursive) {\n      var _this4 = this;\n\n      if (prefix === undefined) prefix = '';\n      if (recursive === undefined) recursive = false;\n      if (!(0, _helpersJs.isValidBucketName)(bucket)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucket);\n      }\n      if (!(0, _helpersJs.isValidPrefix)(prefix)) {\n        throw new errors.InvalidPrefixError('Invalid prefix : ' + prefix);\n      }\n      if (!(0, _helpersJs.isBoolean)(recursive)) {\n        throw new TypeError('recursive should be of type \"boolean\"');\n      }\n      var delimiter = recursive ? '' : '/';\n      var keyMarker = '';\n      var uploadIdMarker = '';\n      var uploads = [];\n      var ended = false;\n      var readStream = _stream2['default'].Readable({ objectMode: true });\n      readStream._read = function () {\n        // push one upload info per _read()\n        if (uploads.length) {\n          return readStream.push(uploads.shift());\n        }\n        if (ended) return readStream.push(null);\n        _this4.listIncompleteUploadsQuery(bucket, prefix, keyMarker, uploadIdMarker, delimiter).on('error', function (e) {\n          return readStream.emit('error', e);\n        }).on('data', function (result) {\n          result.prefixes.forEach(function (prefix) {\n            return uploads.push(prefix);\n          });\n          _async2['default'].eachSeries(result.uploads, function (upload, cb) {\n            // for each incomplete upload add the sizes of its uploaded parts\n            _this4.listParts(bucket, upload.key, upload.uploadId, function (err, parts) {\n              if (err) return cb(err);\n              upload.size = parts.reduce(function (acc, item) {\n                return acc + item.size;\n              }, 0);\n              uploads.push(upload);\n              cb();\n            });\n          }, function (err) {\n            if (err) {\n              readStream.emit('error', err);\n              return;\n            }\n            if (result.isTruncated) {\n              keyMarker = result.nextKeyMarker;\n              uploadIdMarker = result.nextUploadIdMarker;\n            } else {\n              ended = true;\n            }\n            readStream._read();\n          });\n        });\n      };\n      return readStream;\n    }\n\n    // To check if a bucket already exists.\n    //\n    // __Arguments__\n    // * `bucketName` _string_ : name of the bucket\n    // * `callback(err)` _function_ : `err` is `null` if the bucket exists\n  }, {\n    key: 'bucketExists',\n    value: function bucketExists(bucketName, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      var method = 'HEAD';\n      this.makeRequest({ method: method, bucketName: bucketName }, '', 200, '', false, function (err) {\n        if (err) {\n          if (err.code == 'NoSuchBucket' || err.code == 'NotFound') return cb(null, false);\n          return cb(err);\n        }\n        cb(null, true);\n      });\n    }\n\n    // Remove a bucket.\n    //\n    // __Arguments__\n    // * `bucketName` _string_ : name of the bucket\n    // * `callback(err)` _function_ : `err` is `null` if the bucket is removed successfully.\n  }, {\n    key: 'removeBucket',\n    value: function removeBucket(bucketName, cb) {\n      var _this5 = this;\n\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      var method = 'DELETE';\n      this.makeRequest({ method: method, bucketName: bucketName }, '', 204, '', false, function (e) {\n        // If the bucket was successfully removed, remove the region map entry.\n        if (!e) delete _this5.regionMap[bucketName];\n        cb(e);\n      });\n    }\n\n    // Remove the partially uploaded object.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `callback(err)` _function_: callback function is called with non `null` value in case of error\n  }, {\n    key: 'removeIncompleteUpload',\n    value: function removeIncompleteUpload(bucketName, objectName, cb) {\n      var _this6 = this;\n\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.isValidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      var removeUploadId;\n      _async2['default'].during(function (cb) {\n        _this6.findUploadId(bucketName, objectName, function (e, uploadId) {\n          if (e) return cb(e);\n          removeUploadId = uploadId;\n          cb(null, uploadId);\n        });\n      }, function (cb) {\n        var method = 'DELETE';\n        var query = 'uploadId=' + removeUploadId;\n        _this6.makeRequest({ method: method, bucketName: bucketName, objectName: objectName, query: query }, '', 204, '', false, function (e) {\n          return cb(e);\n        });\n      }, cb);\n    }\n\n    // Callback is called with `error` in case of error or `null` in case of success\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `filePath` _string_: path to which the object data will be written to\n    // * `callback(err)` _function_: callback is called with `err` in case of error.\n  }, {\n    key: 'fGetObject',\n    value: function fGetObject(bucketName, objectName, filePath, cb) {\n      var _this7 = this;\n\n      // Input validation.\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isString)(filePath)) {\n        throw new TypeError('filePath should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n\n      // Internal data.\n      var partFile;\n      var partFileStream;\n      var objStat;\n\n      // Rename wrapper.\n      var rename = function rename(err) {\n        if (err) return cb(err);\n        _fs2['default'].rename(partFile, filePath, cb);\n      };\n\n      _async2['default'].waterfall([function (cb) {\n        return _this7.statObject(bucketName, objectName, cb);\n      }, function (result, cb) {\n        objStat = result;\n        // Create any missing top level directories.\n        (0, _mkdirp2['default'])(_path2['default'].dirname(filePath), cb);\n      }, function (ignore, cb) {\n        partFile = filePath + '.' + objStat.etag + '.part.minio';\n        _fs2['default'].stat(partFile, function (e, stats) {\n          var offset = 0;\n          if (e) {\n            partFileStream = _fs2['default'].createWriteStream(partFile, { flags: 'w' });\n          } else {\n            if (objStat.size === stats.size) return rename();\n            offset = stats.size;\n            partFileStream = _fs2['default'].createWriteStream(partFile, { flags: 'a' });\n          }\n          _this7.getPartialObject(bucketName, objectName, offset, 0, cb);\n        });\n      }, function (downloadStream, cb) {\n        (0, _helpersJs.pipesetup)(downloadStream, partFileStream).on('error', function (e) {\n          return cb(e);\n        }).on('finish', cb);\n      }, function (cb) {\n        return _fs2['default'].stat(partFile, cb);\n      }, function (stats, cb) {\n        if (stats.size === objStat.size) return cb();\n        cb(new Error('Size mismatch between downloaded file and the object'));\n      }], rename);\n    }\n\n    // Callback is called with readable stream of the object content.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream\n  }, {\n    key: 'getObject',\n    value: function getObject(bucketName, objectName, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      this.getPartialObject(bucketName, objectName, 0, 0, cb);\n    }\n\n    // Callback is called with readable stream of the partial object content.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `offset` _number_: offset of the object from where the stream will start\n    // * `length` _number_: length of the object that will be read in the stream (optional, if not specified we read the rest of the file from the offset)\n    // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream\n  }, {\n    key: 'getPartialObject',\n    value: function getPartialObject(bucketName, objectName, offset, length, cb) {\n      if ((0, _helpersJs.isFunction)(length)) {\n        cb = length;\n        length = 0;\n      }\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isNumber)(offset)) {\n        throw new TypeError('offset should be of type \"number\"');\n      }\n      if (!(0, _helpersJs.isNumber)(length)) {\n        throw new TypeError('length should be of type \"number\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n\n      var range = '';\n      if (offset || length) {\n        if (offset) {\n          range = 'bytes=' + +offset + '-';\n        } else {\n          range = 'bytes=0-';\n          offset = 0;\n        }\n        if (length) {\n          range += '' + (+length + offset - 1);\n        }\n      }\n\n      var headers = {};\n      if (range !== '') {\n        headers.range = range;\n      }\n\n      var expectedStatus = 200;\n      if (range) {\n        expectedStatus = 206;\n      }\n      var method = 'GET';\n      this.makeRequest({ method: method, bucketName: bucketName, objectName: objectName, headers: headers }, '', expectedStatus, '', true, cb);\n    }\n\n    // Uploads the object using contents from a file\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `filePath` _string_: file path of the file to be uploaded\n    // * `contentType` _string_: content type of the object\n    // * `callback(err, etag)` _function_: non null `err` indicates error, `etag` _string_ is the etag of the object uploaded.\n  }, {\n    key: 'fPutObject',\n    value: function fPutObject(bucketName, objectName, filePath, contentType, callback) {\n      var _this8 = this;\n\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n\n      if (!(0, _helpersJs.isString)(filePath)) {\n        throw new TypeError('filePath should be of type \"string\"');\n      }\n\n      if ((0, _helpersJs.isFunction)(contentType)) {\n        callback = contentType;\n        contentType = ''; // Set contentType empty if no contentType provided.\n      }\n\n      if (!(0, _helpersJs.isString)(contentType)) {\n        throw new TypeError('contentType should be of type \"string\"');\n      }\n\n      // For contentType if empty probe using file extension.\n      if (contentType.trim() === '') {\n        contentType = (0, _helpersJs.probeContentType)(filePath);\n      }\n\n      var size;\n      var partSize;\n\n      _async2['default'].waterfall([function (cb) {\n        return _fs2['default'].stat(filePath, cb);\n      }, function (stats, cb) {\n        size = stats.size;\n        if (size > _this8.maxObjectSize) {\n          return cb(new Error(filePath + ' size : ' + stats.size + ', max allowed size : 5TB'));\n        }\n        if (size < _this8.minimumPartSize) {\n          // simple PUT request, no multipart\n          var multipart = false;\n          var uploader = _this8.getUploader(bucketName, objectName, contentType, multipart);\n          var hash = transformers.getHashSummer(_this8.enableSHA256);\n          var start = 0;\n          var end = size - 1;\n          var autoClose = true;\n          if (size === 0) end = 0;\n          var options = { start: start, end: end, autoClose: autoClose };\n          (0, _helpersJs.pipesetup)(_fs2['default'].createReadStream(filePath, options), hash).on('data', function (data) {\n            var md5sum = data.md5sum;\n            var sha256sum = data.sha256sum;\n            var stream = _fs2['default'].createReadStream(filePath, options);\n            uploader(stream, size, sha256sum, md5sum, function (err, etag) {\n              callback(err, etag);\n              cb(true);\n            });\n          }).on('error', function (e) {\n            return cb(e);\n          });\n          return;\n        }\n        _this8.findUploadId(bucketName, objectName, cb);\n      }, function (uploadId, cb) {\n        // if there was a previous incomplete upload, fetch all its uploaded parts info\n        if (uploadId) return _this8.listParts(bucketName, objectName, uploadId, function (e, etags) {\n          return cb(e, uploadId, etags);\n        });\n        // there was no previous upload, initiate a new one\n        _this8.initiateNewMultipartUpload(bucketName, objectName, '', function (e, uploadId) {\n          return cb(e, uploadId, []);\n        });\n      }, function (uploadId, etags, cb) {\n        partSize = _this8.calculatePartSize(size);\n        var multipart = true;\n        var uploader = _this8.getUploader(bucketName, objectName, contentType, multipart);\n\n        // convert array to object to make things easy\n        var parts = etags.reduce(function (acc, item) {\n          if (!acc[item.part]) {\n            acc[item.part] = item;\n          }\n          return acc;\n        }, {});\n        var partsDone = [];\n        var partNumber = 1;\n        var uploadedSize = 0;\n        _async2['default'].whilst(function () {\n          return uploadedSize < size;\n        }, function (cb) {\n          var part = parts[partNumber];\n          var hash = transformers.getHashSummer(_this8.enableSHA256);\n          var length = partSize;\n          if (length > size - uploadedSize) {\n            length = size - uploadedSize;\n          }\n          var start = uploadedSize;\n          var end = uploadedSize + length - 1;\n          var autoClose = true;\n          var options = { autoClose: autoClose, start: start, end: end };\n          // verify md5sum of each part\n          (0, _helpersJs.pipesetup)(_fs2['default'].createReadStream(filePath, options), hash).on('data', function (data) {\n            var md5sumHex = new Buffer(data.md5sum, 'base64').toString('hex');\n            if (part && md5sumHex === part.etag) {\n              //md5 matches, chunk already uploaded\n              partsDone.push({ part: partNumber, etag: part.etag });\n              partNumber++;\n              uploadedSize += length;\n              return cb();\n            }\n            // part is not uploaded yet, or md5 mismatch\n            var stream = _fs2['default'].createReadStream(filePath, options);\n            uploader(uploadId, partNumber, stream, length, data.sha256sum, data.md5sum, function (e, etag) {\n              if (e) return cb(e);\n              partsDone.push({ part: partNumber, etag: etag });\n              partNumber++;\n              uploadedSize += length;\n              return cb();\n            });\n          }).on('error', function (e) {\n            return cb(e);\n          });\n        }, function (e) {\n          if (e) return cb(e);\n          cb(null, partsDone, uploadId);\n        });\n      },\n      // all parts uploaded, complete the multipart upload\n      function (etags, uploadId, cb) {\n        return _this8.completeMultipartUpload(bucketName, objectName, uploadId, etags, cb);\n      }], function (err) {\n        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          rest[_key - 1] = arguments[_key];\n        }\n\n        if (err === true) return;\n        callback.apply(undefined, [err].concat(rest));\n      });\n    }\n\n    // Uploads the object.\n    //\n    // Uploading a stream\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `stream` _Stream_: Readable stream\n    // * `size` _number_: size of the object (optional)\n    // * `callback(err, etag)` _function_: non null `err` indicates error, `etag` _string_ is the etag of the object uploaded.\n    //\n    // Uploading \"Buffer\" or \"string\"\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `string or Buffer` _Stream_ or _Buffer_: Readable stream\n    // * `callback(err, etag)` _function_: non null `err` indicates error, `etag` _string_ is the etag of the object uploaded.\n  }, {\n    key: 'putObject',\n    value: function putObject(bucketName, objectName, stream, size, contentType, callback) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n\n      // We'll need to shift arguments to the left because of size and contentType.\n      if ((0, _helpersJs.isFunction)(size)) {\n        callback = size;\n        contentType = '';\n      } else if ((0, _helpersJs.isFunction)(contentType)) {\n        callback = contentType;\n        contentType = '';\n      }\n\n      // We'll need to shift arguments to the left because of contentType\n      // and size being optional.\n      if ((0, _helpersJs.isString)(size)) {\n        contentType = size;\n      }\n\n      if (typeof stream === 'string' || stream instanceof Buffer) {\n        // Adapts the non-stream interface into a stream.\n        size = stream.length;\n        stream = (0, _helpersJs.readableStream)(stream);\n      } else if (!(0, _helpersJs.isReadableStream)(stream)) {\n        throw new TypeError('third argument should be of type \"stream.Readable\" or \"Buffer\" or \"string\"');\n      }\n\n      if (!(0, _helpersJs.isFunction)(callback)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n\n      if ((0, _helpersJs.isNumber)(size) && size < 0) {\n        throw new errors.InvalidArgumentError('size cannot be negative, given size: ' + size);\n      }\n\n      // Get the part size and forward that to the BlockStream. Default to the\n      // largest block size possible if necessary.\n      if (!(0, _helpersJs.isNumber)(size)) size = this.maxObjectSize;\n\n      size = this.calculatePartSize(size);\n\n      // s3 requires that all non-end chunks be at least `this.minimumPartSize`,\n      // so we chunk the stream until we hit either that size or the end before\n      // we flush it to s3.\n      var chunker = (0, _blockStream22['default'])({ size: size, zeroPadding: false });\n\n      // This is a Writable stream that can be written to in order to upload\n      // to the specified bucket and object automatically.\n      var uploader = new _objectUploader2['default'](this, bucketName, objectName, size, contentType, callback);\n\n      // stream => chunker => uploader\n      stream.pipe(chunker).pipe(uploader);\n    }\n\n    // Copy the object.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `srcObject` _string_: path of the source object to be copied\n    // * `conditions` _CopyConditions_: copy conditions that needs to be satisfied (optional, default `null`)\n    // * `callback(err, {etag, lastModified})` _function_: non null `err` indicates error, `etag` _string_ and `listModifed` _Date_ are respectively the etag and the last modified date of the newly copied object\n  }, {\n    key: 'copyObject',\n    value: function copyObject(arg1, arg2, arg3, arg4, arg5) {\n      var bucketName = arg1;\n      var objectName = arg2;\n      var srcObject = arg3;\n      var conditions, cb;\n      if (typeof arg4 == 'function' && arg5 === undefined) {\n        conditions = null;\n        cb = arg4;\n      } else {\n        conditions = arg4;\n        cb = arg5;\n      }\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isString)(srcObject)) {\n        throw new TypeError('srcObject should be of type \"string\"');\n      }\n      if (srcObject === \"\") {\n        throw new errors.InvalidPrefixError('Empty source prefix');\n      }\n\n      if (conditions !== null && !(conditions instanceof CopyConditions)) {\n        throw new TypeError('conditions should be of type \"CopyConditions\"');\n      }\n\n      var headers = {};\n      headers['x-amz-copy-source'] = (0, _helpersJs.uriEscape)(srcObject);\n\n      if (conditions !== null) {\n        if (conditions.modified !== \"\") {\n          headers['x-amz-copy-source-if-modified-since'] = conditions.modified;\n        }\n        if (conditions.unmodified !== \"\") {\n          headers['x-amz-copy-source-if-unmodified-since'] = conditions.unmodified;\n        }\n        if (conditions.matchETag !== \"\") {\n          headers['x-amz-copy-source-if-match'] = conditions.matchETag;\n        }\n        if (conditions.matchEtagExcept !== \"\") {\n          headers['x-amz-copy-source-if-none-match'] = conditions.matchETagExcept;\n        }\n      }\n\n      var method = 'PUT';\n      this.makeRequest({ method: method, bucketName: bucketName, objectName: objectName, headers: headers }, '', 200, '', true, function (e, response) {\n        if (e) return cb(e);\n        var transformer = transformers.getCopyObjectTransformer();\n        (0, _helpersJs.pipesetup)(response, transformer).on('error', function (e) {\n          return cb(e);\n        }).on('data', function (data) {\n          return cb(null, data);\n        });\n      });\n    }\n\n    // list a batch of objects\n  }, {\n    key: 'listObjectsQuery',\n    value: function listObjectsQuery(bucketName, prefix, marker, delimiter, maxKeys) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isString)(prefix)) {\n        throw new TypeError('prefix should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isString)(marker)) {\n        throw new TypeError('marker should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isString)(delimiter)) {\n        throw new TypeError('delimiter should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isNumber)(maxKeys)) {\n        throw new TypeError('maxKeys should be of type \"number\"');\n      }\n      var queries = [];\n      // escape every value in query string, except maxKeys\n      if (prefix) {\n        prefix = (0, _helpersJs.uriEscape)(prefix);\n        queries.push('prefix=' + prefix);\n      }\n      if (marker) {\n        marker = (0, _helpersJs.uriEscape)(marker);\n        queries.push('marker=' + marker);\n      }\n      if (delimiter) {\n        delimiter = (0, _helpersJs.uriEscape)(delimiter);\n        queries.push('delimiter=' + delimiter);\n      }\n      // no need to escape maxKeys\n      if (maxKeys) {\n        if (maxKeys >= 1000) {\n          maxKeys = 1000;\n        }\n        queries.push('max-keys=' + maxKeys);\n      }\n      queries.sort();\n      var query = '';\n      if (queries.length > 0) {\n        query = '' + queries.join('&');\n      }\n\n      var method = 'GET';\n      var transformer = transformers.getListObjectsTransformer();\n      this.makeRequest({ method: method, bucketName: bucketName, query: query }, '', 200, '', true, function (e, response) {\n        if (e) return transformer.emit('error', e);\n        (0, _helpersJs.pipesetup)(response, transformer);\n      });\n      return transformer;\n    }\n\n    // List the objects in the bucket.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `prefix` _string_: the prefix of the objects that should be listed (optional, default `''`)\n    // * `recursive` _bool_: `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)\n    //\n    // __Return Value__\n    // * `stream` _Stream_: stream emitting the objects in the bucket, the object is of the format:\n    //   * `obj.name` _string_: name of the object\n    //   * `obj.prefix` _string_: name of the object prefix\n    //   * `obj.size` _number_: size of the object\n    //   * `obj.etag` _string_: etag of the object\n    //   * `obj.lastModified` _Date_: modified time stamp\n  }, {\n    key: 'listObjects',\n    value: function listObjects(bucketName, prefix, recursive) {\n      var _this9 = this;\n\n      if (prefix === undefined) prefix = '';\n      if (recursive === undefined) recursive = false;\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidPrefix)(prefix)) {\n        throw new errors.InvalidPrefixError('Invalid prefix : ' + prefix);\n      }\n      if (!(0, _helpersJs.isString)(prefix)) {\n        throw new TypeError('prefix should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isBoolean)(recursive)) {\n        throw new TypeError('recursive should be of type \"boolean\"');\n      }\n      // if recursive is false set delimiter to '/'\n      var delimiter = recursive ? '' : '/';\n      var marker = '';\n      var objects = [];\n      var ended = false;\n      var readStream = _stream2['default'].Readable({ objectMode: true });\n      readStream._read = function () {\n        // push one object per _read()\n        if (objects.length) {\n          readStream.push(objects.shift());\n          return;\n        }\n        if (ended) return readStream.push(null);\n        // if there are no objects to push do query for the next batch of objects\n        _this9.listObjectsQuery(bucketName, prefix, marker, delimiter, 1000).on('error', function (e) {\n          return readStream.emit('error', e);\n        }).on('data', function (result) {\n          if (result.isTruncated) {\n            marker = result.nextMarker;\n          } else {\n            ended = true;\n          }\n          objects = result.objects;\n          readStream._read();\n        });\n      };\n      return readStream;\n    }\n\n    // list a batch of objects using S3 ListObjects v2\n  }, {\n    key: 'listObjectsV2Query',\n    value: function listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, maxKeys) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isString)(prefix)) {\n        throw new TypeError('prefix should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isString)(continuationToken)) {\n        throw new TypeError('continuationToken should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isString)(delimiter)) {\n        throw new TypeError('delimiter should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isNumber)(maxKeys)) {\n        throw new TypeError('maxKeys should be of type \"number\"');\n      }\n      var queries = [];\n\n      // Call for listing objects v2 API\n      queries.push('list-type=2');\n\n      // escape every value in query string, except maxKeys\n      if (prefix) {\n        prefix = (0, _helpersJs.uriEscape)(prefix);\n        queries.push('prefix=' + prefix);\n      }\n      if (continuationToken) {\n        continuationToken = (0, _helpersJs.uriEscape)(continuationToken);\n        queries.push('continuation-token=' + continuationToken);\n      }\n      if (delimiter) {\n        delimiter = (0, _helpersJs.uriEscape)(delimiter);\n        queries.push('delimiter=' + delimiter);\n      }\n      // no need to escape maxKeys\n      if (maxKeys) {\n        if (maxKeys >= 1000) {\n          maxKeys = 1000;\n        }\n        queries.push('max-keys=' + maxKeys);\n      }\n      queries.sort();\n      var query = '';\n      if (queries.length > 0) {\n        query = '' + queries.join('&');\n      }\n      var method = 'GET';\n      var transformer = transformers.getListObjectsV2Transformer();\n      this.makeRequest({ method: method, bucketName: bucketName, query: query }, '', 200, '', true, function (e, response) {\n        if (e) return transformer.emit('error', e);\n        (0, _helpersJs.pipesetup)(response, transformer);\n      });\n      return transformer;\n    }\n\n    // List the objects in the bucket using S3 ListObjects V2\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `prefix` _string_: the prefix of the objects that should be listed (optional, default `''`)\n    // * `recursive` _bool_: `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)\n    //\n    // __Return Value__\n    // * `stream` _Stream_: stream emitting the objects in the bucket, the object is of the format:\n    //   * `obj.name` _string_: name of the object\n    //   * `obj.prefix` _string_: name of the object prefix\n    //   * `obj.size` _number_: size of the object\n    //   * `obj.etag` _string_: etag of the object\n    //   * `obj.lastModified` _Date_: modified time stamp\n  }, {\n    key: 'listObjectsV2',\n    value: function listObjectsV2(bucketName, prefix, recursive) {\n      var _this10 = this;\n\n      if (prefix === undefined) prefix = '';\n      if (recursive === undefined) recursive = false;\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidPrefix)(prefix)) {\n        throw new errors.InvalidPrefixError('Invalid prefix : ' + prefix);\n      }\n      if (!(0, _helpersJs.isString)(prefix)) {\n        throw new TypeError('prefix should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isBoolean)(recursive)) {\n        throw new TypeError('recursive should be of type \"boolean\"');\n      }\n      // if recursive is false set delimiter to '/'\n      var delimiter = recursive ? '' : '/';\n      var continuationToken = '';\n      var objects = [];\n      var ended = false;\n      var readStream = _stream2['default'].Readable({ objectMode: true });\n      readStream._read = function () {\n        // push one object per _read()\n        if (objects.length) {\n          readStream.push(objects.shift());\n          return;\n        }\n        if (ended) return readStream.push(null);\n        // if there are no objects to push do query for the next batch of objects\n        _this10.listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, 1000).on('error', function (e) {\n          return readStream.emit('error', e);\n        }).on('data', function (result) {\n          if (result.isTruncated) {\n            continuationToken = result.nextContinuationToken;\n          } else {\n            ended = true;\n          }\n          objects = result.objects;\n          readStream._read();\n        });\n      };\n      return readStream;\n    }\n\n    // Stat information of the object.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `callback(err, stat)` _function_: `err` is not `null` in case of error, `stat` contains the object information:\n    //   * `stat.size` _number_: size of the object\n    //   * `stat.etag` _string_: etag of the object\n    //   * `stat.contentType` _string_: Content-Type of the object\n    //   * `stat.lastModified` _Date_: modified time stamp\n  }, {\n    key: 'statObject',\n    value: function statObject(bucketName, objectName, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n\n      var method = 'HEAD';\n      this.makeRequest({ method: method, bucketName: bucketName, objectName: objectName }, '', 200, '', true, function (e, response) {\n        if (e) return cb(e);\n\n        // We drain the socket so that the connection gets closed. Note that this\n        // is not expensive as the socket will not have any data.\n        response.on('data', function () {});\n\n        var result = {\n          size: +response.headers['content-length'],\n          contentType: response.headers['content-type'],\n          lastModified: new Date(response.headers['last-modified'])\n        };\n        var etag = response.headers.etag;\n        if (etag) {\n          etag = etag.replace(/^\"/, '').replace(/\"$/, '');\n          result.etag = etag;\n        }\n        cb(null, result);\n      });\n    }\n\n    // Remove the specified object.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `callback(err)` _function_: callback function is called with non `null` value in case of error\n  }, {\n    key: 'removeObject',\n    value: function removeObject(bucketName, objectName, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      var method = 'DELETE';\n      this.makeRequest({ method: method, bucketName: bucketName, objectName: objectName }, '', 204, '', false, cb);\n    }\n\n    // Get the policy on a bucket or an object prefix.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `callback(err, policy)` _function_: callback function\n  }, {\n    key: 'getBucketPolicy',\n    value: function getBucketPolicy(bucketName, cb) {\n      // Validate arguments.\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n\n      var method = 'GET';\n      var query = 'policy';\n      this.makeRequest({ method: method, bucketName: bucketName, query: query }, '', 200, '', true, function (e, response) {\n        if (e) return cb(e);\n\n        var policy = new Buffer('');\n        (0, _helpersJs.pipesetup)(response, transformers.getConcater()).on('data', function (data) {\n          return policy = data;\n        }).on('error', cb).on('end', function () {\n          cb(null, policy.toString());\n        });\n      });\n    }\n\n    // Set the policy on a bucket or an object prefix.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `bucketPolicy` _string_: bucket policy (JSON stringify'ed)\n    // * `callback(err)` _function_: callback function\n  }, {\n    key: 'setBucketPolicy',\n    value: function setBucketPolicy(bucketName, policy, cb) {\n      // Validate arguments.\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isString)(policy)) {\n        throw new errors.InvalidBucketPolicyError('Invalid bucket policy: ' + policy + ' - must be \"string\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n\n      var method = 'DELETE';\n      var query = 'policy';\n\n      if (policy) {\n        method = 'PUT';\n      }\n\n      this.makeRequest({ method: method, bucketName: bucketName, query: query }, policy, 204, '', false, cb);\n    }\n\n    // Generate a generic presigned URL which can be\n    // used for HTTP methods GET, PUT, HEAD and DELETE\n    //\n    // __Arguments__\n    // * `method` _string_: name of the HTTP method\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `expiry` _number_: expiry in seconds (optional, default 7 days)\n    // * `reqParams` _object_: request parameters (optional)\n  }, {\n    key: 'presignedUrl',\n    value: function presignedUrl(method, bucketName, objectName, expires, reqParams, cb) {\n      var _this11 = this;\n\n      if (this.anonymous) {\n        throw new errors.AnonymousRequestError('Presigned ' + method + ' url cannot be generated for anonymous requests');\n      }\n      if ((0, _helpersJs.isFunction)(reqParams)) {\n        cb = reqParams;\n        reqParams = {};\n      }\n      if ((0, _helpersJs.isFunction)(expires)) {\n        cb = expires;\n        reqParams = {};\n        expires = 24 * 60 * 60 * 7; // 7 days in seconds\n      }\n      if (!(0, _helpersJs.isNumber)(expires)) {\n        throw new TypeError('expires should be of type \"number\"');\n      }\n      if (!(0, _helpersJs.isObject)(reqParams)) {\n        throw new TypeError('reqParams should be of type \"object\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      var requestDate = new Date();\n      var query = _querystring2['default'].stringify(reqParams);\n      this.getBucketRegion(bucketName, function (e, region) {\n        if (e) return cb(e);\n        // This statement is added to ensure that we send error through\n        // callback on presign failure.\n        var url;\n        var reqOptions = _this11.getRequestOptions({ method: method,\n          region: region,\n          bucketName: bucketName,\n          objectName: objectName,\n          query: query });\n        try {\n          url = (0, _signingJs.presignSignatureV4)(reqOptions, _this11.accessKey, _this11.secretKey, region, requestDate, expires);\n        } catch (pe) {\n          return cb(pe);\n        }\n        cb(null, url);\n      });\n    }\n\n    // Generate a presigned URL for GET\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `expiry` _number_: expiry in seconds (optional, default 7 days)\n    // * `respHeaders` _object_: response headers to override (optional)\n  }, {\n    key: 'presignedGetObject',\n    value: function presignedGetObject(bucketName, objectName, expires, respHeaders, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      var validRespHeaders = ['response-content-type', 'response-content-language', 'response-expires', 'response-cache-control', 'response-content-disposition', 'response-content-encoding'];\n      validRespHeaders.forEach(function (header) {\n        if (respHeaders !== undefined && respHeaders[header] !== undefined && !(0, _helpersJs.isString)(respHeaders[header])) {\n          throw new TypeError('response header ' + header + ' should be of type \"string\"');\n        }\n      });\n      return this.presignedUrl('GET', bucketName, objectName, expires, respHeaders, cb);\n    }\n\n    // Generate a presigned URL for PUT. Using this URL, the browser can upload to S3 only with the specified object name.\n    //\n    // __Arguments__\n    // * `bucketName` _string_: name of the bucket\n    // * `objectName` _string_: name of the object\n    // * `expiry` _number_: expiry in seconds (optional, default 7 days)\n  }, {\n    key: 'presignedPutObject',\n    value: function presignedPutObject(bucketName, objectName, expires, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ${bucketName}');\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ${objectName}');\n      }\n      return this.presignedUrl('PUT', bucketName, objectName, expires, cb);\n    }\n\n    // return PostPolicy object\n  }, {\n    key: 'newPostPolicy',\n    value: function newPostPolicy() {\n      return new PostPolicy();\n    }\n\n    // presignedPostPolicy can be used in situations where we want more control on the upload than what\n    // presignedPutObject() provides. i.e Using presignedPostPolicy we will be able to put policy restrictions\n    // on the object's `name` `bucket` `expiry` `Content-Type`\n  }, {\n    key: 'presignedPostPolicy',\n    value: function presignedPostPolicy(postPolicy, cb) {\n      var _this12 = this;\n\n      if (this.anonymous) {\n        throw new errors.AnonymousRequestError('Presigned POST policy cannot be generated for anonymous requests');\n      }\n      if (!(0, _helpersJs.isObject)(postPolicy)) {\n        throw new TypeError('postPolicy should be of type \"object\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('cb should be of type \"function\"');\n      }\n      this.getBucketRegion(postPolicy.formData.bucket, function (e, region) {\n        if (e) return cb(e);\n        var date = new Date();\n        var dateStr = (0, _helpersJs.makeDateLong)(date);\n\n        if (!postPolicy.policy.expiration) {\n          // 'expiration' is mandatory field for S3.\n          // Set default expiration date of 7 days.\n          var expires = new Date();\n          expires.setSeconds(24 * 60 * 60 * 7);\n          postPolicy.setExpires(expires);\n        }\n\n        postPolicy.policy.conditions.push(['eq', '$x-amz-date', dateStr]);\n        postPolicy.formData['x-amz-date'] = dateStr;\n\n        postPolicy.policy.conditions.push(['eq', '$x-amz-algorithm', 'AWS4-HMAC-SHA256']);\n        postPolicy.formData['x-amz-algorithm'] = 'AWS4-HMAC-SHA256';\n\n        postPolicy.policy.conditions.push([\"eq\", \"$x-amz-credential\", _this12.accessKey + \"/\" + (0, _helpersJs.getScope)(region, date)]);\n        postPolicy.formData['x-amz-credential'] = _this12.accessKey + \"/\" + (0, _helpersJs.getScope)(region, date);\n\n        var policyBase64 = new Buffer(JSON.stringify(postPolicy.policy)).toString('base64');\n\n        postPolicy.formData.policy = policyBase64;\n\n        var signature = (0, _signingJs.postPresignSignatureV4)(region, date, _this12.secretKey, policyBase64);\n\n        postPolicy.formData['x-amz-signature'] = signature;\n        var opts = {};\n        opts.region = region;\n        opts.bucketName = postPolicy.formData.bucket;\n        var reqOptions = _this12.getRequestOptions(opts);\n        var portStr = _this12.port == 80 || _this12.port === 443 ? '' : ':' + _this12.port.toString();\n        var urlStr = reqOptions.protocol + '//' + reqOptions.host + portStr + reqOptions.path;\n        cb(null, { postURL: urlStr, formData: postPolicy.formData });\n      });\n    }\n\n    // Calls implemented below are related to multipart.\n\n    // Initiate a new multipart upload.\n  }, {\n    key: 'initiateNewMultipartUpload',\n    value: function initiateNewMultipartUpload(bucketName, objectName, contentType, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isString)(contentType)) {\n        throw new TypeError('contentType should be of type \"string\"');\n      }\n      var method = 'POST';\n      var headers = { 'Content-Type': contentType };\n      var query = 'uploads';\n      this.makeRequest({ method: method, bucketName: bucketName, objectName: objectName, query: query, headers: headers }, '', 200, '', true, function (e, response) {\n        if (e) return cb(e);\n        var transformer = transformers.getInitiateMultipartTransformer();\n        (0, _helpersJs.pipesetup)(response, transformer).on('error', function (e) {\n          return cb(e);\n        }).on('data', function (uploadId) {\n          return cb(null, uploadId);\n        });\n      });\n    }\n\n    // Complete the multipart upload. After all the parts are uploaded issuing\n    // this call will aggregate the parts on the server into a single object.\n  }, {\n    key: 'completeMultipartUpload',\n    value: function completeMultipartUpload(bucketName, objectName, uploadId, etags, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isString)(uploadId)) {\n        throw new TypeError('uploadId should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isObject)(etags)) {\n        throw new TypeError('etags should be of type \"Array\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('cb should be of type \"function\"');\n      }\n\n      if (!uploadId) {\n        throw new errors.InvalidArgumentError('uploadId cannot be empty');\n      }\n\n      var method = 'POST';\n      var query = 'uploadId=' + (0, _helpersJs.uriEscape)(uploadId);\n\n      var parts = [];\n\n      etags.forEach(function (element) {\n        parts.push({\n          Part: [{\n            PartNumber: element.part\n          }, {\n            ETag: element.etag\n          }]\n        });\n      });\n\n      var payloadObject = { CompleteMultipartUpload: parts };\n      var payload = (0, _xml2['default'])(payloadObject);\n\n      this.makeRequest({ method: method, bucketName: bucketName, objectName: objectName, query: query }, payload, 200, '', true, function (e, response) {\n        if (e) return cb(e);\n        var transformer = transformers.getCompleteMultipartTransformer();\n        (0, _helpersJs.pipesetup)(response, transformer).on('error', function (e) {\n          return cb(e);\n        }).on('data', function (result) {\n          if (result.errCode) {\n            // Multipart Complete API returns an error XML after a 200 http status\n            cb(new errors.S3Error(result.errMessage));\n          } else {\n            cb(null, result.etag);\n          }\n        });\n      });\n    }\n\n    // Get part-info of all parts of an incomplete upload specified by uploadId.\n  }, {\n    key: 'listParts',\n    value: function listParts(bucketName, objectName, uploadId, cb) {\n      var _this13 = this;\n\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isString)(uploadId)) {\n        throw new TypeError('uploadId should be of type \"string\"');\n      }\n      if (!uploadId) {\n        throw new errors.InvalidArgumentError('uploadId cannot be empty');\n      }\n      var parts = [];\n      var listNext = function listNext(marker) {\n        _this13.listPartsQuery(bucketName, objectName, uploadId, marker, function (e, result) {\n          if (e) {\n            cb(e);\n            return;\n          }\n          parts = parts.concat(result.parts);\n          if (result.isTruncated) {\n            listNext(result.marker);\n            return;\n          }\n          cb(null, parts);\n        });\n      };\n      listNext(0);\n    }\n\n    // Called by listParts to fetch a batch of part-info\n  }, {\n    key: 'listPartsQuery',\n    value: function listPartsQuery(bucketName, objectName, uploadId, marker, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isString)(uploadId)) {\n        throw new TypeError('uploadId should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isNumber)(marker)) {\n        throw new TypeError('marker should be of type \"number\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      if (!uploadId) {\n        throw new errors.InvalidArgumentError('uploadId cannot be empty');\n      }\n      var query = '';\n      if (marker && marker !== 0) {\n        query += 'part-number-marker=' + marker + '&';\n      }\n      query += 'uploadId=' + (0, _helpersJs.uriEscape)(uploadId);\n\n      var method = 'GET';\n      this.makeRequest({ method: method, bucketName: bucketName, objectName: objectName, query: query }, '', 200, '', true, function (e, response) {\n        if (e) return cb(e);\n        var transformer = transformers.getListPartsTransformer();\n        (0, _helpersJs.pipesetup)(response, transformer).on('error', function (e) {\n          return cb(e);\n        }).on('data', function (data) {\n          return cb(null, data);\n        });\n      });\n    }\n\n    // Called by listIncompleteUploads to fetch a batch of incomplete uploads.\n  }, {\n    key: 'listIncompleteUploadsQuery',\n    value: function listIncompleteUploadsQuery(bucketName, prefix, keyMarker, uploadIdMarker, delimiter) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isString)(prefix)) {\n        throw new TypeError('prefix should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isString)(keyMarker)) {\n        throw new TypeError('keyMarker should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isString)(uploadIdMarker)) {\n        throw new TypeError('uploadIdMarker should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isString)(delimiter)) {\n        throw new TypeError('delimiter should be of type \"string\"');\n      }\n      var queries = [];\n      if (prefix) {\n        queries.push('prefix=' + (0, _helpersJs.uriEscape)(prefix));\n      }\n      if (keyMarker) {\n        keyMarker = (0, _helpersJs.uriEscape)(keyMarker);\n        queries.push('key-marker=' + keyMarker);\n      }\n      if (uploadIdMarker) {\n        queries.push('upload-id-marker=' + uploadIdMarker);\n      }\n      if (delimiter) {\n        queries.push('delimiter=' + (0, _helpersJs.uriEscape)(delimiter));\n      }\n      var maxUploads = 1000;\n      queries.push('max-uploads=' + maxUploads);\n      queries.sort();\n      queries.unshift('uploads');\n      var query = '';\n      if (queries.length > 0) {\n        query = '' + queries.join('&');\n      }\n      var method = 'GET';\n      var transformer = transformers.getListMultipartTransformer();\n      this.makeRequest({ method: method, bucketName: bucketName, query: query }, '', 200, '', true, function (e, response) {\n        if (e) return transformer.emit('error', e);\n        (0, _helpersJs.pipesetup)(response, transformer);\n      });\n      return transformer;\n    }\n\n    // Find uploadId of an incomplete upload.\n  }, {\n    key: 'findUploadId',\n    value: function findUploadId(bucketName, objectName, cb) {\n      var _this14 = this;\n\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('cb should be of type \"function\"');\n      }\n      var latestUpload;\n      var listNext = function listNext(keyMarker, uploadIdMarker) {\n        _this14.listIncompleteUploadsQuery(bucketName, objectName, keyMarker, uploadIdMarker, '').on('error', function (e) {\n          return cb(e);\n        }).on('data', function (result) {\n          result.uploads.forEach(function (upload) {\n            if (upload.key === objectName) {\n              if (!latestUpload || upload.initiated.getTime() > latestUpload.initiated.getTime()) {\n                latestUpload = upload;\n                return;\n              }\n            }\n          });\n          if (result.isTruncated) {\n            listNext(result.nextKeyMarker, result.nextUploadIdMarker);\n            return;\n          }\n          if (latestUpload) return cb(null, latestUpload.uploadId);\n          cb(null, undefined);\n        });\n      };\n      listNext('', '');\n    }\n\n    // Returns a function that can be used for uploading objects.\n    // If multipart === true, it returns function that is used to upload\n    // a part of the multipart.\n  }, {\n    key: 'getUploader',\n    value: function getUploader(bucketName, objectName, contentType, multipart) {\n      var _this15 = this;\n\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);\n      }\n      if (!(0, _helpersJs.isString)(contentType)) {\n        throw new TypeError('contentType should be of type \"string\"');\n      }\n      if (!(0, _helpersJs.isBoolean)(multipart)) {\n        throw new TypeError('multipart should be of type \"boolean\"');\n      }\n      if (contentType === '') {\n        contentType = 'application/octet-stream';\n      }\n\n      var validate = function validate(stream, length, sha256sum, md5sum, cb) {\n        if (!(0, _helpersJs.isReadableStream)(stream)) {\n          throw new TypeError('stream should be of type \"Stream\"');\n        }\n        if (!(0, _helpersJs.isNumber)(length)) {\n          throw new TypeError('length should be of type \"number\"');\n        }\n        if (!(0, _helpersJs.isString)(sha256sum)) {\n          throw new TypeError('sha256sum should be of type \"string\"');\n        }\n        if (!(0, _helpersJs.isString)(md5sum)) {\n          throw new TypeError('md5sum should be of type \"string\"');\n        }\n        if (!(0, _helpersJs.isFunction)(cb)) {\n          throw new TypeError('callback should be of type \"function\"');\n        }\n      };\n      var simpleUploader = function simpleUploader() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        validate.apply(undefined, args);\n        var query = '';\n        upload.apply(undefined, [query].concat(args));\n      };\n      var multipartUploader = function multipartUploader(uploadId, partNumber) {\n        for (var _len3 = arguments.length, rest = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n          rest[_key3 - 2] = arguments[_key3];\n        }\n\n        if (!(0, _helpersJs.isString)(uploadId)) {\n          throw new TypeError('uploadId should be of type \"string\"');\n        }\n        if (!(0, _helpersJs.isNumber)(partNumber)) {\n          throw new TypeError('partNumber should be of type \"number\"');\n        }\n        if (!uploadId) {\n          throw new errors.InvalidArgumentError('Empty uploadId');\n        }\n        if (!partNumber) {\n          throw new errors.InvalidArgumentError('partNumber cannot be 0');\n        }\n        validate.apply(undefined, rest);\n        var query = 'partNumber=' + partNumber + '&uploadId=' + (0, _helpersJs.uriEscape)(uploadId);\n        upload.apply(undefined, [query].concat(rest));\n      };\n      var upload = function upload(query, stream, length, sha256sum, md5sum, cb) {\n        var method = 'PUT';\n        var headers = {\n          'Content-Length': length,\n          'Content-Type': contentType\n        };\n        if (!_this15.enableSHA256) headers['Content-MD5'] = md5sum;\n        _this15.makeRequestStream({ method: method, bucketName: bucketName, objectName: objectName, query: query, headers: headers }, stream, sha256sum, 200, '', true, function (e, response) {\n          if (e) return cb(e);\n          var etag = response.headers.etag;\n          if (etag) {\n            etag = etag.replace(/^\"/, '').replace(/\"$/, '');\n          }\n          // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)\n          response.on('data', function () {});\n          cb(null, etag);\n        });\n      };\n      if (multipart) {\n        return multipartUploader;\n      }\n      return simpleUploader;\n    }\n\n    // Remove all the notification configurations in the S3 provider\n  }, {\n    key: 'setBucketNotification',\n    value: function setBucketNotification(bucketName, config, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isObject)(config)) {\n        throw new TypeError('notification config should be of type \"Object\"');\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      var method = 'PUT';\n      var query = 'notification';\n      var builder = new _xml2js2['default'].Builder({ rootName: 'NotificationConfiguration', renderOpts: { 'pretty': false }, headless: true });\n      var payload = builder.buildObject(config);\n      this.makeRequest({ method: method, bucketName: bucketName, query: query }, payload, 200, '', false, cb);\n    }\n  }, {\n    key: 'removeAllBucketNotification',\n    value: function removeAllBucketNotification(bucketName, cb) {\n      this.setBucketNotification(bucketName, new _notification.NotificationConfig(), cb);\n    }\n\n    // Return the list of notification configurations stored\n    // in the S3 provider\n  }, {\n    key: 'getBucketNotification',\n    value: function getBucketNotification(bucketName, cb) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isFunction)(cb)) {\n        throw new TypeError('callback should be of type \"function\"');\n      }\n      var method = 'GET';\n      var query = 'notification';\n      this.makeRequest({ method: method, bucketName: bucketName, query: query }, '', 200, '', true, function (e, response) {\n        if (e) return cb(e);\n        var transformer = transformers.getBucketNotificationTransformer();\n        var bucketNotification;\n        (0, _helpersJs.pipesetup)(response, transformer).on('data', function (result) {\n          return bucketNotification = result;\n        }).on('error', function (e) {\n          return cb(e);\n        }).on('end', function () {\n          return cb(null, bucketNotification);\n        });\n      });\n    }\n\n    // Listens for bucket notifications. Returns an EventEmitter.\n  }, {\n    key: 'listenBucketNotification',\n    value: function listenBucketNotification(bucketName, prefix, suffix, events) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n      }\n      if (!(0, _helpersJs.isString)(prefix)) {\n        throw new TypeError('prefix must be of type string');\n      }\n      if (!(0, _helpersJs.isString)(suffix)) {\n        throw new TypeError('suffix must be of type string');\n      }\n      if (!(0, _helpersJs.isArray)(events)) {\n        throw new TypeError('events must be of type Array');\n      }\n      var listener = new _notification.NotificationPoller(this, bucketName, prefix, suffix, events);\n      listener.start();\n\n      return listener;\n    }\n  }]);\n\n  return Client;\n})();\n\nexports.Client = Client;\nClient.prototype.makeBucket = (0, _helpersJs.promisify)(Client.prototype.makeBucket);\nClient.prototype.listBuckets = (0, _helpersJs.promisify)(Client.prototype.listBuckets);\nClient.prototype.bucketExists = (0, _helpersJs.promisify)(Client.prototype.bucketExists);\nClient.prototype.removeBucket = (0, _helpersJs.promisify)(Client.prototype.removeBucket);\n\nClient.prototype.getObject = (0, _helpersJs.promisify)(Client.prototype.getObject);\nClient.prototype.getPartialObject = (0, _helpersJs.promisify)(Client.prototype.getPartialObject);\nClient.prototype.fGetObject = (0, _helpersJs.promisify)(Client.prototype.fGetObject);\nClient.prototype.putObject = (0, _helpersJs.promisify)(Client.prototype.putObject);\nClient.prototype.fPutObject = (0, _helpersJs.promisify)(Client.prototype.fPutObject);\nClient.prototype.copyObject = (0, _helpersJs.promisify)(Client.prototype.copyObject);\nClient.prototype.statObject = (0, _helpersJs.promisify)(Client.prototype.statObject);\nClient.prototype.removeObject = (0, _helpersJs.promisify)(Client.prototype.removeObject);\n\nClient.prototype.presignedGetObject = (0, _helpersJs.promisify)(Client.prototype.presignedGetObject);\nClient.prototype.presignedPutObject = (0, _helpersJs.promisify)(Client.prototype.presignedPutObject);\nClient.prototype.presignedPostPolicy = (0, _helpersJs.promisify)(Client.prototype.presignedPostPolicy);\nClient.prototype.getBucketNotification = (0, _helpersJs.promisify)(Client.prototype.getBucketNotification);\nClient.prototype.setBucketNotification = (0, _helpersJs.promisify)(Client.prototype.setBucketNotification);\nClient.prototype.removeAllBucketNotification = (0, _helpersJs.promisify)(Client.prototype.removeAllBucketNotification);\nClient.prototype.getBucketPolicy = (0, _helpersJs.promisify)(Client.prototype.getBucketPolicy);\nClient.prototype.setBucketPolicy = (0, _helpersJs.promisify)(Client.prototype.setBucketPolicy);\nClient.prototype.removeIncompleteUpload = (0, _helpersJs.promisify)(Client.prototype.removeIncompleteUpload);\n\nvar CopyConditions = (function () {\n  function CopyConditions() {\n    _classCallCheck(this, CopyConditions);\n\n    this.modified = \"\";\n    this.unmodified = \"\";\n    this.matchETag = \"\";\n    this.matchETagExcept = \"\";\n  }\n\n  // Build PostPolicy object that can be signed by presignedPostPolicy\n\n  _createClass(CopyConditions, [{\n    key: 'setModified',\n    value: function setModified(date) {\n      if (!(date instanceof Date)) throw new TypeError('date must be of type Date');\n\n      this.modified = date.toUTCString();\n    }\n  }, {\n    key: 'setUnmodified',\n    value: function setUnmodified(date) {\n      if (!(date instanceof Date)) throw new TypeError('date must be of type Date');\n\n      this.unmodified = date.toUTCString();\n    }\n  }, {\n    key: 'setMatchETag',\n    value: function setMatchETag(etag) {\n      this.matchETag = etag;\n    }\n  }, {\n    key: 'setMatchETagExcept',\n    value: function setMatchETagExcept(etag) {\n      this.matchETagExcept = etag;\n    }\n  }]);\n\n  return CopyConditions;\n})();\n\nexports.CopyConditions = CopyConditions;\n\nvar PostPolicy = (function () {\n  function PostPolicy() {\n    _classCallCheck(this, PostPolicy);\n\n    this.policy = {\n      conditions: []\n    };\n    this.formData = {};\n  }\n\n  // set expiration date\n\n  _createClass(PostPolicy, [{\n    key: 'setExpires',\n    value: function setExpires(date) {\n      if (!date) {\n        throw new errors.InvalidDateError('Invalid date : cannot be null');\n      }\n      this.policy.expiration = date.toISOString();\n    }\n\n    // set object name\n  }, {\n    key: 'setKey',\n    value: function setKey(objectName) {\n      if (!(0, _helpersJs.isValidObjectName)(objectName)) {\n        throw new errors.InvalidObjectNameError('Invalid object name : ' + objectName);\n      }\n      this.policy.conditions.push(['eq', '$key', objectName]);\n      this.formData.key = objectName;\n    }\n\n    // set object name prefix, i.e policy allows any keys with this prefix\n  }, {\n    key: 'setKeyStartsWith',\n    value: function setKeyStartsWith(prefix) {\n      if (!(0, _helpersJs.isValidPrefix)(prefix)) {\n        throw new errors.InvalidPrefixError('Invalid prefix : ' + prefix);\n      }\n      this.policy.conditions.push(['starts-with', '$key', prefix]);\n      this.formData.key = prefix;\n    }\n\n    // set bucket name\n  }, {\n    key: 'setBucket',\n    value: function setBucket(bucketName) {\n      if (!(0, _helpersJs.isValidBucketName)(bucketName)) {\n        throw new errors.InvalidBucketNameError('Invalid bucket name : ' + bucketName);\n      }\n      this.policy.conditions.push(['eq', '$bucket', bucketName]);\n      this.formData.bucket = bucketName;\n    }\n\n    // set Content-Type\n  }, {\n    key: 'setContentType',\n    value: function setContentType(type) {\n      if (!type) {\n        throw new Error('content-type cannot be null');\n      }\n      this.policy.conditions.push(['eq', '$Content-Type', type]);\n      this.formData['Content-Type'] = type;\n    }\n\n    // set minimum/maximum length of what Content-Length can be.\n  }, {\n    key: 'setContentLengthRange',\n    value: function setContentLengthRange(min, max) {\n      if (min > max) {\n        throw new Error('min cannot be more than max');\n      }\n      if (min < 0) {\n        throw new Error('min should be > 0');\n      }\n      if (max < 0) {\n        throw new Error('max should be > 0');\n      }\n      this.policy.conditions.push(['content-length-range', min, max]);\n    }\n  }]);\n\n  return PostPolicy;\n})();\n\nexports.PostPolicy = PostPolicy;\n\n_defaults(exports, _interopExportWildcard(_notification, _defaults));\n//# sourceMappingURL=minio.js.map\n\n\n//# sourceURL=webpack:///./node_modules/minio/dist/main/minio.js?");

/***/ }),

/***/ "./node_modules/minio/dist/main/notification.js":
/*!******************************************************!*\
  !*** ./node_modules/minio/dist/main/notification.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _events = __webpack_require__(/*! events */ \"events\");\n\nvar _transformers = __webpack_require__(/*! ./transformers */ \"./node_modules/minio/dist/main/transformers.js\");\n\nvar transformers = _interopRequireWildcard(_transformers);\n\nvar _helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/minio/dist/main/helpers.js\");\n\n// Notification config - array of target configs.\n// Target configs can be\n// 1. Topic (simple notification service)\n// 2. Queue (simple queue service)\n// 3. CloudFront (lambda function)\n\nvar NotificationConfig = (function () {\n  function NotificationConfig() {\n    _classCallCheck(this, NotificationConfig);\n  }\n\n  // Base class for three supported configs.\n\n  _createClass(NotificationConfig, [{\n    key: 'add',\n    value: function add(target) {\n      var instance = '';\n      if (target instanceof TopicConfig) {\n        instance = 'TopicConfiguration';\n      }\n      if (target instanceof QueueConfig) {\n        instance = 'QueueConfiguration';\n      }\n      if (target instanceof CloudFunctionConfig) {\n        instance = 'CloudFunctionConfiguration';\n      }\n      if (!this[instance]) this[instance] = [];\n      this[instance].push(target);\n    }\n  }]);\n\n  return NotificationConfig;\n})();\n\nexports.NotificationConfig = NotificationConfig;\n\nvar TargetConfig = (function () {\n  function TargetConfig() {\n    _classCallCheck(this, TargetConfig);\n  }\n\n  // 1. Topic (simple notification service)\n\n  _createClass(TargetConfig, [{\n    key: 'setId',\n    value: function setId(id) {\n      this.Id = id;\n    }\n  }, {\n    key: 'addEvent',\n    value: function addEvent(newevent) {\n      if (!this.Event) this.Event = [];\n      this.Event.push(newevent);\n    }\n  }, {\n    key: 'addFilterSuffix',\n    value: function addFilterSuffix(suffix) {\n      if (!this.Filter) this.Filter = { S3Key: { FilterRule: [] } };\n      this.Filter.S3Key.FilterRule.push({ Name: \"suffix\", Value: suffix });\n    }\n  }, {\n    key: 'addFilterPrefix',\n    value: function addFilterPrefix(prefix) {\n      if (!this.Filter) this.Filter = { S3Key: { FilterRule: [] } };\n      this.Filter.S3Key.FilterRule.push({ Name: \"prefix\", Value: prefix });\n    }\n  }]);\n\n  return TargetConfig;\n})();\n\nvar TopicConfig = (function (_TargetConfig) {\n  _inherits(TopicConfig, _TargetConfig);\n\n  function TopicConfig(arn) {\n    _classCallCheck(this, TopicConfig);\n\n    _get(Object.getPrototypeOf(TopicConfig.prototype), 'constructor', this).call(this);\n    this.Topic = arn;\n  }\n\n  // 2. Queue (simple queue service)\n  return TopicConfig;\n})(TargetConfig);\n\nexports.TopicConfig = TopicConfig;\n\nvar QueueConfig = (function (_TargetConfig2) {\n  _inherits(QueueConfig, _TargetConfig2);\n\n  function QueueConfig(arn) {\n    _classCallCheck(this, QueueConfig);\n\n    _get(Object.getPrototypeOf(QueueConfig.prototype), 'constructor', this).call(this);\n    this.Queue = arn;\n  }\n\n  // 3. CloudFront (lambda function)\n  return QueueConfig;\n})(TargetConfig);\n\nexports.QueueConfig = QueueConfig;\n\nvar CloudFunctionConfig = (function (_TargetConfig3) {\n  _inherits(CloudFunctionConfig, _TargetConfig3);\n\n  function CloudFunctionConfig(arn) {\n    _classCallCheck(this, CloudFunctionConfig);\n\n    _get(Object.getPrototypeOf(CloudFunctionConfig.prototype), 'constructor', this).call(this);\n    this.CloudFunction = arn;\n  }\n\n  return CloudFunctionConfig;\n})(TargetConfig);\n\nexports.CloudFunctionConfig = CloudFunctionConfig;\nvar buildARN = function buildARN(partition, service, region, accountId, resource) {\n  return \"arn:\" + partition + \":\" + service + \":\" + region + \":\" + accountId + \":\" + resource;\n};\n\nexports.buildARN = buildARN;\nvar ObjectCreatedAll = \"s3:ObjectCreated:*\";\nexports.ObjectCreatedAll = ObjectCreatedAll;\nvar ObjectCreatedPut = \"s3:ObjectCreated:Put\";\nexports.ObjectCreatedPut = ObjectCreatedPut;\nvar ObjectCreatedPost = \"s3:ObjectCreated:Post\";\nexports.ObjectCreatedPost = ObjectCreatedPost;\nvar ObjectCreatedCopy = \"s3:ObjectCreated:Copy\";\nexports.ObjectCreatedCopy = ObjectCreatedCopy;\nvar ObjectCreatedCompleteMultipartUpload = \"sh:ObjectCreated:CompleteMultipartUpload\";\nexports.ObjectCreatedCompleteMultipartUpload = ObjectCreatedCompleteMultipartUpload;\nvar ObjectRemovedAll = \"s3:ObjectRemoved:*\";\nexports.ObjectRemovedAll = ObjectRemovedAll;\nvar ObjectRemovedDelete = \"s3:ObjectRemoved:Delete\";\nexports.ObjectRemovedDelete = ObjectRemovedDelete;\nvar ObjectRemovedDeleteMarkerCreated = \"s3:ObjectRemoved:DeleteMarkerCreated\";\nexports.ObjectRemovedDeleteMarkerCreated = ObjectRemovedDeleteMarkerCreated;\nvar ObjectReducedRedundancyLostObject = \"s3:ReducedRedundancyLostObject\";\n\nexports.ObjectReducedRedundancyLostObject = ObjectReducedRedundancyLostObject;\n// Poll for notifications, used in #listenBucketNotification.\n// Listening constitutes repeatedly requesting s3 whether or not any\n// changes have occurred.\n\nvar NotificationPoller = (function (_EventEmitter) {\n  _inherits(NotificationPoller, _EventEmitter);\n\n  function NotificationPoller(client, bucketName, prefix, suffix, events) {\n    _classCallCheck(this, NotificationPoller);\n\n    _get(Object.getPrototypeOf(NotificationPoller.prototype), 'constructor', this).call(this);\n\n    this.client = client;\n    this.bucketName = bucketName;\n    this.prefix = prefix;\n    this.suffix = suffix;\n    this.events = events;\n\n    this.ending = false;\n  }\n\n  // Starts the polling.\n\n  _createClass(NotificationPoller, [{\n    key: 'start',\n    value: function start() {\n      var _this = this;\n\n      this.ending = false;\n\n      process.nextTick(function () {\n        _this.checkForChanges();\n      });\n    }\n\n    // Stops the polling.\n  }, {\n    key: 'stop',\n    value: function stop() {\n      this.ending = true;\n    }\n  }, {\n    key: 'checkForChanges',\n    value: function checkForChanges() {\n      var _this2 = this;\n\n      // Don't continue if we're looping again but are cancelled.\n      if (this.ending) return;\n\n      var method = 'GET';\n      var queries = [];\n      if (this.prefix) {\n        var prefix = (0, _helpers.uriEscape)(this.prefix);\n        queries.push('prefix=' + prefix);\n      }\n      if (this.suffix) {\n        var suffix = (0, _helpers.uriEscape)(this.suffix);\n        queries.push('suffix=' + suffix);\n      }\n      if (this.events) {\n        this.events.forEach(function (s3event) {\n          return queries.push('events=' + (0, _helpers.uriEscape)(s3event));\n        });\n      }\n      queries.sort();\n\n      var query = '';\n      if (queries.length > 0) {\n        query = '' + queries.join('&');\n      }\n      this.client.makeRequest({ method: method, bucketName: this.bucketName, query: query }, '', 200, '', true, function (e, response) {\n        if (e) return _this2.emit('error', e);\n\n        var transformer = transformers.getNotificationTransformer();\n        (0, _helpers.pipesetup)(response, transformer).on('data', function (result) {\n          // Data is flushed periodically (every 5 seconds), so we should\n          // handle it after flushing from the JSON parser.\n          var records = result.Records;\n          // If null (= no records), change to an empty array.\n          if (!records) records = [];\n\n          // Iterate over the notifications and emit them individually.\n          records.forEach(function (record) {\n            _this2.emit('notification', record);\n          });\n\n          // If we're done, stop.\n          if (_this2.ending) response.destroy();\n        }).on('error', function (e) {\n          return _this2.emit('error', e);\n        }).on('end', function () {\n          // Do it again, if we haven't cancelled yet.\n          process.nextTick(function () {\n            _this2.checkForChanges();\n          });\n        });\n      });\n    }\n  }]);\n\n  return NotificationPoller;\n})(_events.EventEmitter);\n\nexports.NotificationPoller = NotificationPoller;\n//# sourceMappingURL=notification.js.map\n\n\n//# sourceURL=webpack:///./node_modules/minio/dist/main/notification.js?");

/***/ }),

/***/ "./node_modules/minio/dist/main/object-uploader.js":
/*!*********************************************************!*\
  !*** ./node_modules/minio/dist/main/object-uploader.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _stream = __webpack_require__(/*! stream */ \"stream\");\n\nvar _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nvar _querystring = __webpack_require__(/*! querystring */ \"querystring\");\n\nvar querystring = _interopRequireWildcard(_querystring);\n\n// We extend Transform because Writable does not implement ._flush().\n\nvar ObjectUploader = (function (_Transform) {\n  _inherits(ObjectUploader, _Transform);\n\n  function ObjectUploader(client, bucketName, objectName, partSize, contentType, callback) {\n    _classCallCheck(this, ObjectUploader);\n\n    _get(Object.getPrototypeOf(ObjectUploader.prototype), 'constructor', this).call(this);\n    this.emptyStream = true;\n    this.client = client;\n    this.bucketName = bucketName;\n    this.objectName = objectName;\n    // The size of each multipart, chunked by BlockStream2.\n    this.partSize = partSize;\n\n    // This contentType for the object.\n    this.contentType = contentType;\n\n    // Call like: callback(error, etag).\n    this.callback = callback;\n\n    // We need to keep track of what number chunk/part we're on. This increments\n    // each time _write() is called. Starts with 1, not 0.\n    this.partNumber = 1;\n\n    // A list of the previously uploaded chunks, for resuming a file upload. This\n    // will be null if we aren't resuming an upload.\n    this.oldParts = null;\n\n    // Keep track of the etags for aggregating the chunks together later. Each\n    // etag represents a single chunk of the file.\n    this.etags = [];\n\n    // This is for the multipart upload request — if null, we're either not initiated\n    // yet or we're flushing in one packet.\n    this.id = null;\n\n    // Handle errors.\n    this.on('error', function (err) {\n      callback(err);\n    });\n  }\n\n  _createClass(ObjectUploader, [{\n    key: '_transform',\n    value: function _transform(chunk, encoding, callback) {\n      var _this = this;\n\n      this.emptyStream = false;\n      var method = 'PUT';\n      var headers = {\n        'Content-Length': chunk.length,\n        'Content-Type': this.contentType\n      };\n\n      var md5digest = '';\n\n      // Calculate and set Content-MD5 header if SHA256 is not set.\n      // This will happen only when there is a secure connection to the s3 server.\n      if (!this.client.enableSHA256) {\n        md5digest = _crypto2['default'].createHash('md5').update(chunk).digest();\n        headers['Content-MD5'] = md5digest.toString('base64');\n      }\n      // We can flush the object in one packet if it fits in one chunk. This is true\n      // if the chunk size is smaller than the part size, signifying the end of the\n      // stream.\n      if (this.partNumber == 1 && chunk.length < this.partSize) {\n        // PUT the chunk in a single request — use an empty query.\n        var _options = {\n          method: method, headers: headers,\n          query: '',\n          bucketName: this.bucketName,\n          objectName: this.objectName\n        };\n\n        this.client.makeRequest(_options, chunk, 200, '', true, function (err, response) {\n          if (err) return callback(err);\n\n          var etag = response.headers.etag;\n          if (etag) {\n            etag = etag.replace(/^\"/, '').replace(/\"$/, '');\n          }\n\n          // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)\n          response.on('data', function () {});\n\n          // Give the etag back, we're done!\n          process.nextTick(function () {\n            _this.callback(null, etag);\n          });\n\n          // Because we're sure the stream has ended, allow it to flush and end.\n          callback();\n        });\n\n        return;\n      }\n\n      // If we aren't flushing in one packet, we need to initiate the multipart upload,\n      // if it hasn't already been done. The write will be buffered until the upload has been\n      // initiated.\n      if (this.id === null) {\n        this.once('ready', function () {\n          _this._transform(chunk, encoding, callback);\n        });\n\n        // Check for an incomplete previous upload.\n        this.client.findUploadId(this.bucketName, this.objectName, function (err, id) {\n          if (err) return _this.emit('error', err);\n\n          // If no upload ID exists, initiate a new one.\n          if (!id) {\n            _this.client.initiateNewMultipartUpload(_this.bucketName, _this.objectName, _this.contentType, function (err, id) {\n              if (err) return callback(err);\n\n              _this.id = id;\n\n              // We are now ready to accept new chunks — this will flush the buffered chunk.\n              _this.emit('ready');\n            });\n\n            return;\n          }\n\n          _this.id = id;\n\n          // Retrieve the pre-uploaded parts, if we need to resume the upload.\n          _this.client.listParts(_this.bucketName, _this.objectName, id, function (err, etags) {\n            if (err) return _this.emit('error', err);\n\n            // It is possible for no parts to be already uploaded.\n            if (!etags) etags = [];\n\n            // oldParts will become an object, allowing oldParts[partNumber].etag\n            _this.oldParts = etags.reduce(function (prev, item) {\n              if (!prev[item.part]) {\n                prev[item.part] = item;\n              }\n              return prev;\n            }, {});\n\n            _this.emit('ready');\n          });\n        });\n\n        return;\n      }\n\n      // Continue uploading various parts if we have initiated multipart upload.\n      var partNumber = this.partNumber++;\n\n      // Check to see if we've already uploaded this chunk. If the hash sums match,\n      // we can skip to the next chunk.\n      if (this.oldParts) {\n        var oldPart = this.oldParts[partNumber];\n\n        //Calulcate the md5 hash, if it has not already been calculated.\n        if (!md5digest) {\n          md5digest = _crypto2['default'].createHash('md5').update(chunk).digest();\n        }\n\n        if (oldPart && md5digest.toString('hex') === oldPart.etag) {\n          // The md5 matches, the chunk has already been uploaded.\n          this.etags.push({ part: partNumber, etag: oldPart.etag });\n\n          callback();\n          return;\n        }\n      }\n\n      // Write the chunk with an uploader.\n      var query = querystring.stringify({\n        partNumber: partNumber,\n        uploadId: this.id\n      });\n\n      var options = {\n        method: method, query: query, headers: headers,\n        bucketName: this.bucketName,\n        objectName: this.objectName\n      };\n\n      this.client.makeRequest(options, chunk, 200, '', true, function (err, response) {\n        if (err) return callback(err);\n\n        // In order to aggregate the parts together, we need to collect the etags.\n        var etag = response.headers.etag;\n        if (etag) etag = etag.replace(/^\"/, '').replace(/\"$/, '');\n\n        _this.etags.push({ part: partNumber, etag: etag });\n\n        // We're ready for the next chunk.\n        callback();\n      });\n    }\n  }, {\n    key: '_flush',\n    value: function _flush(callback) {\n      var _this2 = this;\n\n      if (this.emptyStream) {\n        var method = 'PUT';\n        var headers = {\n          'Content-Length': 0,\n          'Content-Type': this.contentType\n        };\n        var options = {\n          method: method, headers: headers,\n          query: '',\n          bucketName: this.bucketName,\n          objectName: this.objectName\n        };\n\n        this.client.makeRequest(options, '', 200, '', true, function (err, response) {\n          if (err) return callback(err);\n\n          var etag = response.headers.etag;\n          if (etag) {\n            etag = etag.replace(/^\"/, '').replace(/\"$/, '');\n          }\n\n          // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)\n          response.on('data', function () {});\n\n          // Give the etag back, we're done!\n          process.nextTick(function () {\n            _this2.callback(null, etag);\n          });\n\n          // Because we're sure the stream has ended, allow it to flush and end.\n          callback();\n        });\n\n        return;\n      }\n      // If it has been uploaded in a single packet, we don't have to do anything.\n      if (this.id === null) {\n        return;\n      }\n\n      // This is called when all of the chunks uploaded successfully, thus\n      // completing the multipart upload.\n      this.client.completeMultipartUpload(this.bucketName, this.objectName, this.id, this.etags, function (err, etag) {\n        if (err) return callback(err);\n\n        // Call our callback on the next tick to allow the streams infrastructure\n        // to finish what its doing before we continue.\n        process.nextTick(function () {\n          _this2.callback(null, etag);\n        });\n\n        callback();\n      });\n    }\n  }]);\n\n  return ObjectUploader;\n})(_stream.Transform);\n\nexports['default'] = ObjectUploader;\nmodule.exports = exports['default'];\n//# sourceMappingURL=object-uploader.js.map\n\n\n//# sourceURL=webpack:///./node_modules/minio/dist/main/object-uploader.js?");

/***/ }),

/***/ "./node_modules/minio/dist/main/s3-endpoints.js":
/*!******************************************************!*\
  !*** ./node_modules/minio/dist/main/s3-endpoints.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015, 2016 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getS3Endpoint = getS3Endpoint;\n\nvar _helpersJs = __webpack_require__(/*! ./helpers.js */ \"./node_modules/minio/dist/main/helpers.js\");\n\n// List of currently supported endpoints.\nvar awsS3Endpoint = {\n  'us-east-1': 's3.amazonaws.com',\n  'us-east-2': 's3-us-east-2.amazonaws.com',\n  'us-west-1': 's3-us-west-1.amazonaws.com',\n  'us-west-2': 's3-us-west-2.amazonaws.com',\n  'ca-central-1': 's3.ca-central-1.amazonaws.com',\n  'eu-west-1': 's3-eu-west-1.amazonaws.com',\n  'eu-west-2': 's3-eu-west-2.amazonaws.com',\n  'sa-east-1': 's3-sa-east-1.amazonaws.com',\n  'eu-central-1': 's3-eu-central-1.amazonaws.com',\n  'ap-south-1': 's3-ap-south-1.amazonaws.com',\n  'ap-southeast-1': 's3-ap-southeast-1.amazonaws.com',\n  'ap-southeast-2': 's3-ap-southeast-2.amazonaws.com',\n  'ap-northeast-1': 's3-ap-northeast-1.amazonaws.com',\n  'cn-north-1': 's3.cn-north-1.amazonaws.com.cn'\n  // Add new endpoints here.\n};\n\n// getS3Endpoint get relevant endpoint for the region.\n\nfunction getS3Endpoint(region) {\n  if (!(0, _helpersJs.isString)(region)) {\n    throw new TypeError('Invalid region: ' + region);\n  }\n  var endpoint = awsS3Endpoint[region];\n  if (endpoint) {\n    return endpoint;\n  }\n  return 's3.amazonaws.com';\n}\n//# sourceMappingURL=s3-endpoints.js.map\n\n\n//# sourceURL=webpack:///./node_modules/minio/dist/main/s3-endpoints.js?");

/***/ }),

/***/ "./node_modules/minio/dist/main/signing.js":
/*!*************************************************!*\
  !*** ./node_modules/minio/dist/main/signing.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.postPresignSignatureV4 = postPresignSignatureV4;\nexports.signV4 = signV4;\nexports.presignSignatureV4 = presignSignatureV4;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nvar _lodash = __webpack_require__(/*! lodash */ \"lodash\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _helpersJs = __webpack_require__(/*! ./helpers.js */ \"./node_modules/minio/dist/main/helpers.js\");\n\nvar _errorsJs = __webpack_require__(/*! ./errors.js */ \"./node_modules/minio/dist/main/errors.js\");\n\nvar errors = _interopRequireWildcard(_errorsJs);\n\nvar signV4Algorithm = 'AWS4-HMAC-SHA256';\n\n// getCanonicalRequest generate a canonical request of style.\n//\n// canonicalRequest =\n//  <HTTPMethod>\\n\n//  <CanonicalURI>\\n\n//  <CanonicalQueryString>\\n\n//  <CanonicalHeaders>\\n\n//  <SignedHeaders>\\n\n//  <HashedPayload>\n//\nfunction getCanonicalRequest(method, path, headers, signedHeaders, hashedPayload) {\n  if (!(0, _helpersJs.isString)(method)) {\n    throw new TypeError('method should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isString)(path)) {\n    throw new TypeError('path should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isObject)(headers)) {\n    throw new TypeError('headers should be of type \"object\"');\n  }\n  if (!(0, _helpersJs.isArray)(signedHeaders)) {\n    throw new TypeError('signedHeaders should be of type \"array\"');\n  }\n  if (!(0, _helpersJs.isString)(hashedPayload)) {\n    throw new TypeError('hashedPayload should be of type \"string\"');\n  }\n  var headersArray = signedHeaders.reduce(function (acc, i) {\n    acc.push(i.toLowerCase() + ':' + headers[i]);\n    return acc;\n  }, []);\n\n  var requestResource = path.split('?')[0];\n  var requestQuery = path.split('?')[1];\n  if (!requestQuery) requestQuery = '';\n\n  if (requestQuery) {\n    requestQuery = requestQuery.split('&').sort().map(function (element) {\n      return element.indexOf('=') === -1 ? element + '=' : element;\n    }).join('&');\n  }\n\n  var canonical = [];\n  canonical.push(method.toUpperCase());\n  canonical.push(requestResource);\n  canonical.push(requestQuery);\n  canonical.push(headersArray.join('\\n') + '\\n');\n  canonical.push(signedHeaders.join(';').toLowerCase());\n  canonical.push(hashedPayload);\n  return canonical.join('\\n');\n}\n\n// generate a credential string\nfunction getCredential(accessKey, region, requestDate) {\n  if (!(0, _helpersJs.isString)(accessKey)) {\n    throw new TypeError('accessKey should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isString)(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isObject)(requestDate)) {\n    throw new TypeError('requestDate should be of type \"object\"');\n  }\n  return accessKey + '/' + (0, _helpersJs.getScope)(region, requestDate);\n}\n\n// Returns signed headers array - alphabetically sorted\nfunction getSignedHeaders(headers) {\n  if (!(0, _helpersJs.isObject)(headers)) {\n    throw new TypeError('request should be of type \"object\"');\n  }\n  // Excerpts from @lsegal - https://github.com/aws/aws-sdk-js/issues/659#issuecomment-120477258\n  //\n  //  User-Agent:\n  //\n  //      This is ignored from signing because signing this causes problems with generating pre-signed URLs\n  //      (that are executed by other agents) or when customers pass requests through proxies, which may\n  //      modify the user-agent.\n  //\n  //  Content-Length:\n  //\n  //      This is ignored from signing because generating a pre-signed URL should not provide a content-length\n  //      constraint, specifically when vending a S3 pre-signed PUT URL. The corollary to this is that when\n  //      sending regular requests (non-pre-signed), the signature contains a checksum of the body, which\n  //      implicitly validates the payload length (since changing the number of bytes would change the checksum)\n  //      and therefore this header is not valuable in the signature.\n  //\n  //  Content-Type:\n  //\n  //      Signing this header causes quite a number of problems in browser environments, where browsers\n  //      like to modify and normalize the content-type header in different ways. There is more information\n  //      on this in https://github.com/aws/aws-sdk-js/issues/244. Avoiding this field simplifies logic\n  //      and reduces the possibility of future bugs\n  //\n  //  Authorization:\n  //\n  //      Is skipped for obvious reasons\n\n  var ignoredHeaders = ['authorization', 'content-length', 'content-type', 'user-agent'];\n  return _lodash2['default'].map(headers, function (v, header) {\n    return header;\n  }).filter(function (header) {\n    return ignoredHeaders.indexOf(header) === -1;\n  }).sort();\n}\n\n// returns the key used for calculating signature\nfunction getSigningKey(date, region, secretKey) {\n  if (!(0, _helpersJs.isObject)(date)) {\n    throw new TypeError('date should be of type \"object\"');\n  }\n  if (!(0, _helpersJs.isString)(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isString)(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"');\n  }\n  var dateLine = (0, _helpersJs.makeDateShort)(date),\n      hmac1 = _crypto2['default'].createHmac('sha256', 'AWS4' + secretKey).update(dateLine).digest(),\n      hmac2 = _crypto2['default'].createHmac('sha256', hmac1).update(region).digest(),\n      hmac3 = _crypto2['default'].createHmac('sha256', hmac2).update('s3').digest();\n  return _crypto2['default'].createHmac('sha256', hmac3).update('aws4_request').digest();\n}\n\n// returns the string that needs to be signed\nfunction getStringToSign(canonicalRequest, requestDate, region) {\n  if (!(0, _helpersJs.isString)(canonicalRequest)) {\n    throw new TypeError('canonicalRequest should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isObject)(requestDate)) {\n    throw new TypeError('requestDate should be of type \"object\"');\n  }\n  if (!(0, _helpersJs.isString)(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  var hash = _crypto2['default'].createHash('sha256').update(canonicalRequest).digest('hex');\n  var scope = (0, _helpersJs.getScope)(region, requestDate);\n  var stringToSign = [];\n  stringToSign.push(signV4Algorithm);\n  stringToSign.push((0, _helpersJs.makeDateLong)(requestDate));\n  stringToSign.push(scope);\n  stringToSign.push(hash);\n  return stringToSign.join('\\n');\n}\n\n// calculate the signature of the POST policy\n\nfunction postPresignSignatureV4(region, date, secretKey, policyBase64) {\n  if (!(0, _helpersJs.isString)(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isObject)(date)) {\n    throw new TypeError('date should be of type \"object\"');\n  }\n  if (!(0, _helpersJs.isString)(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isString)(policyBase64)) {\n    throw new TypeError('policyBase64 should be of type \"string\"');\n  }\n  var signingKey = getSigningKey(date, region, secretKey);\n  return _crypto2['default'].createHmac('sha256', signingKey).update(policyBase64).digest('hex').toLowerCase();\n}\n\n// Returns the authorization header\n\nfunction signV4(request, accessKey, secretKey, region, requestDate) {\n  if (!(0, _helpersJs.isObject)(request)) {\n    throw new TypeError('request should be of type \"object\"');\n  }\n  if (!(0, _helpersJs.isString)(accessKey)) {\n    throw new TypeError('accessKey should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isString)(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isString)(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n\n  if (!accessKey) {\n    throw new errors.AccessKeyRequiredError('accessKey is required for signing');\n  }\n  if (!secretKey) {\n    throw new errors.SecretKeyRequiredError('secretKey is required for signing');\n  }\n\n  var sha256sum = request.headers['x-amz-content-sha256'];\n\n  var signedHeaders = getSignedHeaders(request.headers);\n  var canonicalRequest = getCanonicalRequest(request.method, request.path, request.headers, signedHeaders, sha256sum);\n  var stringToSign = getStringToSign(canonicalRequest, requestDate, region);\n  var signingKey = getSigningKey(requestDate, region, secretKey);\n  var credential = getCredential(accessKey, region, requestDate);\n  var signature = _crypto2['default'].createHmac('sha256', signingKey).update(stringToSign).digest('hex').toLowerCase();\n\n  return signV4Algorithm + ' Credential=' + credential + ', SignedHeaders=' + signedHeaders.join(';').toLowerCase() + ', Signature=' + signature;\n}\n\n// returns a presigned URL string\n\nfunction presignSignatureV4(request, accessKey, secretKey, region, requestDate, expires) {\n  if (!(0, _helpersJs.isObject)(request)) {\n    throw new TypeError('request should be of type \"object\"');\n  }\n  if (!(0, _helpersJs.isString)(accessKey)) {\n    throw new TypeError('accessKey should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isString)(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"');\n  }\n  if (!(0, _helpersJs.isString)(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n\n  if (!accessKey) {\n    throw new errors.AccessKeyRequiredError('accessKey is required for presigning');\n  }\n  if (!secretKey) {\n    throw new errors.SecretKeyRequiredError('secretKey is required for presigning');\n  }\n\n  if (!(0, _helpersJs.isNumber)(expires)) {\n    throw new TypeError('expires should be of type \"number\"');\n  }\n  if (expires < 1) {\n    throw new errors.ExpiresParamError('expires param cannot be less than 1 seconds');\n  }\n  if (expires > 604800) {\n    throw new errors.ExpiresParamError('expires param cannot be greater than 7 days');\n  }\n\n  var iso8601Date = (0, _helpersJs.makeDateLong)(requestDate);\n  var signedHeaders = getSignedHeaders(request.headers);\n  var credential = getCredential(accessKey, region, requestDate);\n  var hashedPayload = 'UNSIGNED-PAYLOAD';\n\n  var requestQuery = [];\n  requestQuery.push('X-Amz-Algorithm=' + signV4Algorithm);\n  requestQuery.push('X-Amz-Credential=' + (0, _helpersJs.uriEscape)(credential));\n  requestQuery.push('X-Amz-Date=' + iso8601Date);\n  requestQuery.push('X-Amz-Expires=' + expires);\n  requestQuery.push('X-Amz-SignedHeaders=' + (0, _helpersJs.uriEscape)(signedHeaders.join(';').toLowerCase()));\n\n  var resource = request.path.split('?')[0];\n  var query = request.path.split('?')[1];\n  if (query) {\n    query = query + '&' + requestQuery.join('&');\n  } else {\n    query = requestQuery.join('&');\n  }\n\n  var path = resource + '?' + query;\n\n  var canonicalRequest = getCanonicalRequest(request.method, path, request.headers, signedHeaders, hashedPayload);\n\n  var stringToSign = getStringToSign(canonicalRequest, requestDate, region);\n  var signingKey = getSigningKey(requestDate, region, secretKey);\n  var signature = _crypto2['default'].createHmac('sha256', signingKey).update(stringToSign).digest('hex').toLowerCase();\n  var presignedUrl = request.protocol + '//' + request.headers.host + path + ('&X-Amz-Signature=' + signature);\n  return presignedUrl;\n}\n//# sourceMappingURL=signing.js.map\n\n\n//# sourceURL=webpack:///./node_modules/minio/dist/main/signing.js?");

/***/ }),

/***/ "./node_modules/minio/dist/main/transformers.js":
/*!******************************************************!*\
  !*** ./node_modules/minio/dist/main/transformers.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015, 2016 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getConcater = getConcater;\nexports.getErrorTransformer = getErrorTransformer;\nexports.getHashSummer = getHashSummer;\nexports.getCopyObjectTransformer = getCopyObjectTransformer;\nexports.getListBucketTransformer = getListBucketTransformer;\nexports.getListMultipartTransformer = getListMultipartTransformer;\nexports.getListPartsTransformer = getListPartsTransformer;\nexports.getInitiateMultipartTransformer = getInitiateMultipartTransformer;\nexports.getListObjectsTransformer = getListObjectsTransformer;\nexports.getListObjectsV2Transformer = getListObjectsV2Transformer;\nexports.getCompleteMultipartTransformer = getCompleteMultipartTransformer;\nexports.getBucketRegionTransformer = getBucketRegionTransformer;\nexports.getBucketNotificationTransformer = getBucketNotificationTransformer;\nexports.getNotificationTransformer = getNotificationTransformer;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _xmlParsersJs = __webpack_require__(/*! ./xml-parsers.js */ \"./node_modules/minio/dist/main/xml-parsers.js\");\n\nvar xmlParsers = _interopRequireWildcard(_xmlParsersJs);\n\nvar _lodash = __webpack_require__(/*! lodash */ \"lodash\");\n\nvar _ = _interopRequireWildcard(_lodash);\n\nvar _through2 = __webpack_require__(/*! through2 */ \"through2\");\n\nvar _through22 = _interopRequireDefault(_through2);\n\nvar _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nvar _jsonStream = __webpack_require__(/*! json-stream */ \"./node_modules/json-stream/lib/json-stream.js\");\n\nvar _jsonStream2 = _interopRequireDefault(_jsonStream);\n\nvar _helpersJs = __webpack_require__(/*! ./helpers.js */ \"./node_modules/minio/dist/main/helpers.js\");\n\nvar _errorsJs = __webpack_require__(/*! ./errors.js */ \"./node_modules/minio/dist/main/errors.js\");\n\nvar errors = _interopRequireWildcard(_errorsJs);\n\n// getConcater returns a stream that concatenates the input and emits\n// the concatenated output when 'end' has reached. If an optional\n// parser function is passed upon reaching the 'end' of the stream,\n// `parser(concatenated_data)` will be emitted.\n\nfunction getConcater(parser, emitError) {\n  var objectMode = false;\n  var bufs = [];\n\n  if (parser && !(0, _helpersJs.isFunction)(parser)) {\n    throw new TypeError('parser should be of type \"function\"');\n  }\n\n  if (parser) {\n    objectMode = true;\n  }\n\n  return (0, _through22['default'])({ objectMode: objectMode }, function (chunk, enc, cb) {\n    bufs.push(chunk);\n    cb();\n  }, function (cb) {\n    if (emitError) {\n      cb(parser(Buffer.concat(bufs).toString()));\n      // cb(e) would mean we have to emit 'end' by explicitly calling this.push(null)\n      this.push(null);\n      return;\n    }\n    if (bufs.length) {\n      if (parser) {\n        this.push(parser(Buffer.concat(bufs).toString()));\n      } else {\n        this.push(Buffer.concat(bufs));\n      }\n    }\n    cb();\n  });\n}\n\n// Generates an Error object depending on http statusCode and XML body\n\nfunction getErrorTransformer(response) {\n  var statusCode = response.statusCode;\n  var code, message;\n  if (statusCode === 301) {\n    code = 'MovedPermanently';\n    message = 'Moved Permanently';\n  } else if (statusCode === 307) {\n    code = 'TemporaryRedirect';\n    message = 'Are you using the correct endpoint URL?';\n  } else if (statusCode === 403) {\n    code = 'AccessDenied';\n    message = 'Valid and authorized credentials required';\n  } else if (statusCode === 404) {\n    code = 'NotFound';\n    message = 'Not Found';\n  } else if (statusCode === 405) {\n    code = 'MethodNotAllowed';\n    message = 'Method Not Allowed';\n  } else if (statusCode === 501) {\n    code = 'MethodNotAllowed';\n    message = 'Method Not Allowed';\n  } else {\n    code = 'UnknownError';\n    message = '' + statusCode;\n  }\n\n  var headerInfo = {};\n  // A value created by S3 compatible server that uniquely identifies\n  // the request.\n  headerInfo.amzRequestid = response.headersSent ? response.getHeader('x-amz-request-id') : null;\n  // A special token that helps troubleshoot API replies and issues.\n  headerInfo.amzId2 = response.headersSent ? response.getHeader('x-amz-id-2') : null;\n  // Region where the bucket is located. This header is returned only\n  // in HEAD bucket and ListObjects response.\n  headerInfo.amzBucketRegion = response.headersSent ? response.getHeader('x-amz-bucket-region') : null;\n\n  return getConcater(function (xmlString) {\n    var getError = function getError() {\n      // Message should be instantiated for each S3Errors.\n      var e = new errors.S3Error(message);\n      // S3 Error code.\n      e.code = code;\n      _.each(headerInfo, function (value, key) {\n        e[key] = value;\n      });\n      return e;\n    };\n    if (!xmlString) {\n      return getError();\n    }\n    var e = undefined;\n    try {\n      e = xmlParsers.parseError(xmlString, headerInfo);\n    } catch (ex) {\n      return getError();\n    }\n    return e;\n  }, true);\n}\n\n// A through stream that calculates md5sum and sha256sum\n\nfunction getHashSummer(enableSHA256) {\n  var md5 = _crypto2['default'].createHash('md5');\n  var sha256 = _crypto2['default'].createHash('sha256');\n\n  return _through22['default'].obj(function (chunk, enc, cb) {\n\n    if (enableSHA256) {\n      sha256.update(chunk);\n    } else {\n      md5.update(chunk);\n    }\n    cb();\n  }, function (cb) {\n    var md5sum = '';\n    var sha256sum = '';\n    if (enableSHA256) {\n      sha256sum = sha256.digest('hex');\n    } else {\n      md5sum = md5.digest('base64');\n    }\n    var hashData = { md5sum: md5sum, sha256sum: sha256sum };\n    this.push(hashData);\n    this.push(null);\n    cb();\n  });\n}\n\n// Following functions return a stream object that parses XML\n// and emits suitable Javascript objects.\n\n// Parses CopyObject response.\n\nfunction getCopyObjectTransformer() {\n  return getConcater(xmlParsers.parseCopyObject);\n}\n\n// Parses listBuckets response.\n\nfunction getListBucketTransformer() {\n  return getConcater(xmlParsers.parseListBucket);\n}\n\n// Parses listMultipartUploads response.\n\nfunction getListMultipartTransformer() {\n  return getConcater(xmlParsers.parseListMultipart);\n}\n\n// Parses listParts response.\n\nfunction getListPartsTransformer() {\n  return getConcater(xmlParsers.parseListParts);\n}\n\n// Parses initMultipartUpload response.\n\nfunction getInitiateMultipartTransformer() {\n  return getConcater(xmlParsers.parseInitiateMultipart);\n}\n\n// Parses listObjects response.\n\nfunction getListObjectsTransformer() {\n  return getConcater(xmlParsers.parseListObjects);\n}\n\n// Parses listObjects response.\n\nfunction getListObjectsV2Transformer() {\n  return getConcater(xmlParsers.parseListObjectsV2);\n}\n\n// Parses completeMultipartUpload response.\n\nfunction getCompleteMultipartTransformer() {\n  return getConcater(xmlParsers.parseCompleteMultipart);\n}\n\n// Parses getBucketLocation response.\n\nfunction getBucketRegionTransformer() {\n  return getConcater(xmlParsers.parseBucketRegion);\n}\n\n// Parses GET/SET BucketNotification response\n\nfunction getBucketNotificationTransformer() {\n  return getConcater(xmlParsers.parseBucketNotification);\n}\n\n// Parses a notification.\n\nfunction getNotificationTransformer() {\n  // This will parse and return each object.\n  return new _jsonStream2['default']();\n}\n//# sourceMappingURL=transformers.js.map\n\n\n//# sourceURL=webpack:///./node_modules/minio/dist/main/transformers.js?");

/***/ }),

/***/ "./node_modules/minio/dist/main/xml-parsers.js":
/*!*****************************************************!*\
  !*** ./node_modules/minio/dist/main/xml-parsers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.parseError = parseError;\nexports.parseCopyObject = parseCopyObject;\nexports.parseListMultipart = parseListMultipart;\nexports.parseListBucket = parseListBucket;\nexports.parseBucketNotification = parseBucketNotification;\nexports.parseBucketRegion = parseBucketRegion;\nexports.parseListParts = parseListParts;\nexports.parseInitiateMultipart = parseInitiateMultipart;\nexports.parseCompleteMultipart = parseCompleteMultipart;\nexports.parseListObjects = parseListObjects;\nexports.parseListObjectsV2 = parseListObjectsV2;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _xml2js = __webpack_require__(/*! xml2js */ \"./node_modules/xml2js/lib/xml2js.js\");\n\nvar _xml2js2 = _interopRequireDefault(_xml2js);\n\nvar _lodash = __webpack_require__(/*! lodash */ \"lodash\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _errorsJs = __webpack_require__(/*! ./errors.js */ \"./node_modules/minio/dist/main/errors.js\");\n\nvar errors = _interopRequireWildcard(_errorsJs);\n\nvar options = { // options passed to xml2js parser\n  explicitRoot: false, // return the root node in the resulting object?\n  ignoreAttrs: true };\n\n// ignore attributes, only create text nodes\nvar parseXml = function parseXml(xml) {\n  var result = null;\n  var error = null;\n\n  var parser = new _xml2js2['default'].Parser(options);\n  parser.parseString(xml, function (e, r) {\n    error = e;\n    result = r;\n  });\n\n  if (error) {\n    throw new Error('XML parse error');\n  }\n  return result;\n};\n\n// Parse XML and return information as Javascript types\n\n// parse error XML response\n\nfunction parseError(xml, headerInfo) {\n  var xmlError = {};\n  var xmlobj = parseXml(xml);\n  var message;\n  _lodash2['default'].each(xmlobj, function (n, key) {\n    if (key === 'Message') {\n      message = xmlobj[key][0];\n      return;\n    }\n    xmlError[key.toLowerCase()] = xmlobj[key][0];\n  });\n  var e = new errors.S3Error(message);\n  _lodash2['default'].each(xmlError, function (value, key) {\n    e[key] = value;\n  });\n  _lodash2['default'].each(headerInfo, function (value, key) {\n    e[key] = value;\n  });\n  return e;\n}\n\n// parse XML response for copy object\n\nfunction parseCopyObject(xml) {\n  var result = {\n    etag: \"\",\n    lastModified: \"\"\n  };\n  var xmlobj = parseXml(xml);\n  if (xmlobj.ETag) result.etag = xmlobj.ETag[0].replace(/^\"/g, '').replace(/\"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');\n  if (xmlobj.LastModified) result.lastModified = new Date(xmlobj.LastModified[0]);\n\n  return result;\n}\n\n// parse XML response for listing in-progress multipart uploads\n\nfunction parseListMultipart(xml) {\n  var result = {\n    uploads: [],\n    prefixes: [],\n    isTruncated: false\n  };\n  var xmlobj = parseXml(xml);\n  if (xmlobj.IsTruncated && xmlobj.IsTruncated[0] === 'true') result.isTruncated = true;\n  if (xmlobj.NextKeyMarker) result.nextKeyMarker = xmlobj.NextKeyMarker[0];\n  if (xmlobj.NextUploadIdMarker) result.nextUploadIdMarker = xmlobj.NextUploadIdMarker[0];\n  if (xmlobj.CommonPrefixes) xmlobj.CommonPrefixes.forEach(function (prefix) {\n    result.prefixes.push({ prefix: prefix[0] });\n  });\n  if (xmlobj.Upload) xmlobj.Upload.forEach(function (upload) {\n    result.uploads.push({\n      key: upload.Key[0],\n      uploadId: upload.UploadId[0],\n      initiated: new Date(upload.Initiated[0])\n    });\n  });\n  return result;\n}\n\n// parse XML response to list all the owned buckets\n\nfunction parseListBucket(xml) {\n  var result = [];\n  var xmlobj = parseXml(xml);\n  if (xmlobj.Buckets) {\n    if (xmlobj.Buckets[0].Bucket) {\n      xmlobj.Buckets[0].Bucket.forEach(function (bucket) {\n        var name = bucket.Name[0];\n        var creationDate = new Date(bucket.CreationDate[0]);\n        result.push({ name: name, creationDate: creationDate });\n      });\n    }\n  }\n  return result;\n}\n\n// parse XML response for bucket notification\n\nfunction parseBucketNotification(xml) {\n  var result = {\n    TopicConfiguration: [],\n    QueueConfiguration: [],\n    CloudFunctionConfiguration: []\n  };\n  // Parse the events list\n  var genEvents = function genEvents(events) {\n    var result = [];\n    if (events) {\n      events.forEach(function (s3event) {\n        result.push(s3event);\n      });\n    }\n    return result;\n  };\n  // Parse all filter rules\n  var genFilterRules = function genFilterRules(filters) {\n    var result = [];\n    if (filters && filters[0].S3Key && filters[0].S3Key[0].FilterRule) {\n      filters[0].S3Key[0].FilterRule.forEach(function (rule) {\n        var Name = rule.Name[0];\n        var Value = rule.Value[0];\n        result.push({ Name: Name, Value: Value });\n      });\n    }\n    return result;\n  };\n\n  var xmlobj = parseXml(xml);\n\n  // Parse all topic configurations in the xml\n  if (xmlobj.TopicConfiguration) {\n    xmlobj.TopicConfiguration.forEach(function (config) {\n      var Id = config.Id[0];\n      var Topic = config.Topic[0];\n      var Event = genEvents(config.Event);\n      var Filter = genFilterRules(config.Filter);\n      result.TopicConfiguration.push({ Id: Id, Topic: Topic, Event: Event, Filter: Filter });\n    });\n  }\n  // Parse all topic configurations in the xml\n  if (xmlobj.QueueConfiguration) {\n    xmlobj.QueueConfiguration.forEach(function (config) {\n      var Id = config.Id[0];\n      var Queue = config.Queue[0];\n      var Event = genEvents(config.Event);\n      var Filter = genFilterRules(config.Filter);\n      result.QueueConfiguration.push({ Id: Id, Queue: Queue, Event: Event, Filter: Filter });\n    });\n  }\n  // Parse all QueueConfiguration arrays\n  if (xmlobj.CloudFunctionConfiguration) {\n    xmlobj.CloudFunctionConfiguration.forEach(function (config) {\n      var Id = config.Id[0];\n      var CloudFunction = config.CloudFunction[0];\n      var Event = genEvents(config.Event);\n      var Filter = genFilterRules(config.Filter);\n      result.CloudFunctionConfiguration.push({ Id: Id, CloudFunction: CloudFunction, Event: Event, Filter: Filter });\n    });\n  }\n\n  return result;\n}\n\n// parse XML response for bucket region\n\nfunction parseBucketRegion(xml) {\n  return parseXml(xml);\n}\n\n// parse XML response for list parts of an in progress multipart upload\n\nfunction parseListParts(xml) {\n  var xmlobj = parseXml(xml);\n  var result = {\n    isTruncated: false,\n    parts: [],\n    marker: undefined\n  };\n  if (xmlobj.IsTruncated && xmlobj.IsTruncated[0] === 'true') result.isTruncated = true;\n  if (xmlobj.NextPartNumberMarker) result.marker = +xmlobj.NextPartNumberMarker[0];\n  if (xmlobj.Part) {\n    xmlobj.Part.forEach(function (p) {\n      var part = +p.PartNumber[0];\n      var lastModified = new Date(p.LastModified[0]);\n      var etag = p.ETag[0].replace(/^\"/g, '').replace(/\"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');\n      result.parts.push({ part: part, lastModified: lastModified, etag: etag });\n    });\n  }\n  return result;\n}\n\n// parse XML response when a new multipart upload is initiated\n\nfunction parseInitiateMultipart(xml) {\n  var xmlobj = parseXml(xml);\n  if (xmlobj.UploadId) return xmlobj.UploadId[0];\n  throw new errors.InvalidXMLError('UploadId missing in XML');\n}\n\n// parse XML response when a multipart upload is completed\n\nfunction parseCompleteMultipart(xml) {\n  var xmlobj = parseXml(xml);\n  if (xmlobj.Location) {\n    var location = xmlobj.Location[0];\n    var bucket = xmlobj.Bucket[0];\n    var key = xmlobj.Key[0];\n    var etag = xmlobj.ETag[0].replace(/^\"/g, '').replace(/\"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');\n\n    return { location: location, bucket: bucket, key: key, etag: etag };\n  }\n  // Complete Multipart can return XML Error after a 200 OK response\n  if (xmlobj.Code && xmlobj.Message) {\n    var errCode = xmlobj.Code[0];\n    var errMessage = xmlobj.Message[0];\n    return { errCode: errCode, errMessage: errMessage };\n  }\n}\n\n// parse XML response for list objects in a bucket\n\nfunction parseListObjects(xml) {\n  var result = {\n    objects: [],\n    isTruncated: false\n  };\n  var nextMarker;\n  var xmlobj = parseXml(xml);\n  if (xmlobj.IsTruncated && xmlobj.IsTruncated[0] === 'true') result.isTruncated = true;\n  if (xmlobj.Contents) {\n    xmlobj.Contents.forEach(function (content) {\n      var name = content.Key[0];\n      var lastModified = new Date(content.LastModified[0]);\n      var etag = content.ETag[0].replace(/^\"/g, '').replace(/\"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');\n      var size = +content.Size[0];\n      result.objects.push({ name: name, lastModified: lastModified, etag: etag, size: size });\n      nextMarker = name;\n    });\n  }\n  if (xmlobj.CommonPrefixes) {\n    xmlobj.CommonPrefixes.forEach(function (commonPrefix) {\n      var prefix = commonPrefix.Prefix[0];\n      var size = 0;\n      result.objects.push({ prefix: prefix, size: size });\n    });\n  }\n  if (result.isTruncated) {\n    result.nextMarker = xmlobj.NextMarker ? xmlobj.NextMarker[0] : nextMarker;\n  }\n  return result;\n}\n\n// parse XML response for list objects v2 in a bucket\n\nfunction parseListObjectsV2(xml) {\n  var result = {\n    objects: [],\n    isTruncated: false\n  };\n  var xmlobj = parseXml(xml);\n  if (xmlobj.IsTruncated && xmlobj.IsTruncated[0] === 'true') result.isTruncated = true;\n  if (xmlobj.NextContinuationToken) result.nextContinuationToken = xmlobj.NextContinuationToken[0];\n\n  if (xmlobj.Contents) {\n    xmlobj.Contents.forEach(function (content) {\n      var name = content.Key[0];\n      var lastModified = new Date(content.LastModified[0]);\n      var etag = content.ETag[0].replace(/^\"/g, '').replace(/\"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');\n      var size = +content.Size[0];\n      result.objects.push({ name: name, lastModified: lastModified, etag: etag, size: size });\n    });\n  }\n  if (xmlobj.CommonPrefixes) {\n    xmlobj.CommonPrefixes.forEach(function (commonPrefix) {\n      var prefix = commonPrefix.Prefix[0];\n      var size = 0;\n      result.objects.push({ prefix: prefix, size: size });\n    });\n  }\n  return result;\n}\n//# sourceMappingURL=xml-parsers.js.map\n\n\n//# sourceURL=webpack:///./node_modules/minio/dist/main/xml-parsers.js?");

/***/ }),

/***/ "./node_modules/minio/package.json":
/*!*****************************************!*\
  !*** ./node_modules/minio/package.json ***!
  \*****************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, engines, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = {\"_from\":\"minio\",\"_id\":\"minio@5.0.2\",\"_inBundle\":false,\"_integrity\":\"sha1-Wxi1RGSisoI4c5HivcpkL85qp8M=\",\"_location\":\"/minio\",\"_phantomChildren\":{\"core-util-is\":\"1.0.2\",\"inherits\":\"2.0.3\",\"xtend\":\"4.0.1\"},\"_requested\":{\"type\":\"tag\",\"registry\":true,\"raw\":\"minio\",\"name\":\"minio\",\"escapedName\":\"minio\",\"rawSpec\":\"\",\"saveSpec\":null,\"fetchSpec\":\"latest\"},\"_requiredBy\":[\"#USER\",\"/\"],\"_resolved\":\"https://registry.npmjs.org/minio/-/minio-5.0.2.tgz\",\"_shasum\":\"5b18b54464a2b282387391e2bdca642fce6aa7c3\",\"_spec\":\"minio\",\"_where\":\"/home/dania/Desktop/Text-Summarizer-Backend-master\",\"author\":{\"name\":\"Minio, Inc.\",\"url\":\"https://minio.io\"},\"bugs\":{\"url\":\"https://github.com/minio/minio-js/issues\"},\"bundleDependencies\":false,\"dependencies\":{\"async\":\"^1.5.2\",\"block-stream2\":\"^1.0.0\",\"concat-stream\":\"^1.4.8\",\"es6-error\":\"^2.0.2\",\"json-stream\":\"^1.0.0\",\"lodash\":\"^4.14.2\",\"mime-types\":\"^2.1.14\",\"mkdirp\":\"^0.5.1\",\"querystring\":\"0.2.0\",\"source-map-support\":\"^0.4.12\",\"through2\":\"^0.6.5\",\"uuid\":\"^3.1.0\",\"xml\":\"^1.0.0\",\"xml2js\":\"^0.4.15\"},\"deprecated\":false,\"description\":\"S3 Compatible Cloud Storage client\",\"devDependencies\":{\"browserify\":\"^12.0.1\",\"chai\":\"^3.5.0\",\"eslint\":\"^4.1.1\",\"gulp\":\"^3.9.0\",\"gulp-babel\":\"^5.2.1\",\"gulp-eslint\":\"^4.0.0\",\"gulp-mocha\":\"^2.1.0\",\"gulp-notify\":\"^2.2.0\",\"gulp-sourcemaps\":\"^1.5.2\",\"mocha\":\"^2.3.2\",\"mocha-steps\":\"^1.1.0\",\"nock\":\"^2.12.0\",\"rewire\":\"^2.3.3\",\"superagent\":\"^1.8.5\"},\"engines\":{\"node\":\">= 0.10.0\"},\"homepage\":\"https://github.com/minio/minio-js#readme\",\"keywords\":[\"api\",\"amazon\",\"minio\",\"cloud\",\"s3\",\"storage\"],\"license\":\"Apache-2.0\",\"main\":\"./dist/main/minio.js\",\"name\":\"minio\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/minio/minio-js.git\"},\"scripts\":{\"browserify\":\"gulp browserify\",\"compile\":\"gulp compile\",\"functional\":\"gulp functional-test\",\"prepublish\":\"gulp test\",\"test\":\"gulp test\"},\"version\":\"5.0.2\"};\n\n//# sourceURL=webpack:///./node_modules/minio/package.json?");

/***/ }),

/***/ "./node_modules/sax/lib/sax.js":
/*!*************************************!*\
  !*** ./node_modules/sax/lib/sax.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = __webpack_require__(/*! stream */ \"stream\").Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = __webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})( false ? undefined : exports)\n\n\n//# sourceURL=webpack:///./node_modules/sax/lib/sax.js?");

/***/ }),

/***/ "./node_modules/xml/lib/escapeForXML.js":
/*!**********************************************!*\
  !*** ./node_modules/xml/lib/escapeForXML.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nvar XML_CHARACTER_MAP = {\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&apos;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\n\nfunction escapeForXML(string) {\n    return string && string.replace\n        ? string.replace(/([&\"<>'])/g, function(str, item) {\n            return XML_CHARACTER_MAP[item];\n          })\n        : string;\n}\n\nmodule.exports = escapeForXML;\n\n\n//# sourceURL=webpack:///./node_modules/xml/lib/escapeForXML.js?");

/***/ }),

/***/ "./node_modules/xml/lib/xml.js":
/*!*************************************!*\
  !*** ./node_modules/xml/lib/xml.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var escapeForXML = __webpack_require__(/*! ./escapeForXML */ \"./node_modules/xml/lib/escapeForXML.js\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\").Stream;\n\nvar DEFAULT_INDENT = '    ';\n\nfunction xml(input, options) {\n\n    if (typeof options !== 'object') {\n        options = {\n            indent: options\n        };\n    }\n\n    var stream      = options.stream ? new Stream() : null,\n        output      = \"\",\n        interrupted = false,\n        indent      = !options.indent ? ''\n                        : options.indent === true ? DEFAULT_INDENT\n                            : options.indent,\n        instant     = true;\n\n\n    function delay (func) {\n        if (!instant) {\n            func();\n        } else {\n            process.nextTick(func);\n        }\n    }\n\n    function append (interrupt, out) {\n        if (out !== undefined) {\n            output += out;\n        }\n        if (interrupt && !interrupted) {\n            stream = stream || new Stream();\n            interrupted = true;\n        }\n        if (interrupt && interrupted) {\n            var data = output;\n            delay(function () { stream.emit('data', data) });\n            output = \"\";\n        }\n    }\n\n    function add (value, last) {\n        format(append, resolve(value, indent, indent ? 1 : 0), last);\n    }\n\n    function end() {\n        if (stream) {\n            var data = output;\n            delay(function () {\n              stream.emit('data', data);\n              stream.emit('end');\n              stream.readable = false;\n              stream.emit('close');\n            });\n        }\n    }\n\n    function addXmlDeclaration(declaration) {\n        var encoding = declaration.encoding || 'UTF-8',\n            attr =  { version: '1.0', encoding: encoding };\n\n        if (declaration.standalone) {\n            attr.standalone = declaration.standalone\n        }\n\n        add({'?xml': { _attr: attr } });\n        output = output.replace('/>', '?>');\n    }\n\n    // disable delay delayed\n    delay(function () { instant = false });\n\n    if (options.declaration) {\n        addXmlDeclaration(options.declaration);\n    }\n\n    if (input && input.forEach) {\n        input.forEach(function (value, i) {\n            var last;\n            if (i + 1 === input.length)\n                last = end;\n            add(value, last);\n        });\n    } else {\n        add(input, end);\n    }\n\n    if (stream) {\n        stream.readable = true;\n        return stream;\n    }\n    return output;\n}\n\nfunction element (/*input, …*/) {\n    var input = Array.prototype.slice.call(arguments),\n        self = {\n            _elem:  resolve(input)\n        };\n\n    self.push = function (input) {\n        if (!this.append) {\n            throw new Error(\"not assigned to a parent!\");\n        }\n        var that = this;\n        var indent = this._elem.indent;\n        format(this.append, resolve(\n            input, indent, this._elem.icount + (indent ? 1 : 0)),\n            function () { that.append(true) });\n    };\n\n    self.close = function (input) {\n        if (input !== undefined) {\n            this.push(input);\n        }\n        if (this.end) {\n            this.end();\n        }\n    };\n\n    return self;\n}\n\nfunction create_indent(character, count) {\n    return (new Array(count || 0).join(character || ''))\n}\n\nfunction resolve(data, indent, indent_count) {\n    indent_count = indent_count || 0;\n    var indent_spaces = create_indent(indent, indent_count);\n    var name;\n    var values = data;\n    var interrupt = false;\n\n    if (typeof data === 'object') {\n        var keys = Object.keys(data);\n        name = keys[0];\n        values = data[name];\n\n        if (values && values._elem) {\n            values._elem.name = name;\n            values._elem.icount = indent_count;\n            values._elem.indent = indent;\n            values._elem.indents = indent_spaces;\n            values._elem.interrupt = values;\n            return values._elem;\n        }\n    }\n\n    var attributes = [],\n        content = [];\n\n    var isStringContent;\n\n    function get_attributes(obj){\n        var keys = Object.keys(obj);\n        keys.forEach(function(key){\n            attributes.push(attribute(key, obj[key]));\n        });\n    }\n\n    switch(typeof values) {\n        case 'object':\n            if (values === null) break;\n\n            if (values._attr) {\n                get_attributes(values._attr);\n            }\n\n            if (values._cdata) {\n                content.push(\n                    ('<![CDATA[' + values._cdata).replace(/\\]\\]>/g, ']]]]><![CDATA[>') + ']]>'\n                );\n            }\n\n            if (values.forEach) {\n                isStringContent = false;\n                content.push('');\n                values.forEach(function(value) {\n                    if (typeof value == 'object') {\n                        var _name = Object.keys(value)[0];\n\n                        if (_name == '_attr') {\n                            get_attributes(value._attr);\n                        } else {\n                            content.push(resolve(\n                                value, indent, indent_count + 1));\n                        }\n                    } else {\n                        //string\n                        content.pop();\n                        isStringContent=true;\n                        content.push(escapeForXML(value));\n                    }\n\n                });\n                if (!isStringContent) {\n                    content.push('');\n                }\n            }\n        break;\n\n        default:\n            //string\n            content.push(escapeForXML(values));\n\n    }\n\n    return {\n        name:       name,\n        interrupt:  interrupt,\n        attributes: attributes,\n        content:    content,\n        icount:     indent_count,\n        indents:    indent_spaces,\n        indent:     indent\n    };\n}\n\nfunction format(append, elem, end) {\n\n    if (typeof elem != 'object') {\n        return append(false, elem);\n    }\n\n    var len = elem.interrupt ? 1 : elem.content.length;\n\n    function proceed () {\n        while (elem.content.length) {\n            var value = elem.content.shift();\n\n            if (value === undefined) continue;\n            if (interrupt(value)) return;\n\n            format(append, value);\n        }\n\n        append(false, (len > 1 ? elem.indents : '')\n            + (elem.name ? '</' + elem.name + '>' : '')\n            + (elem.indent && !end ? '\\n' : ''));\n\n        if (end) {\n            end();\n        }\n    }\n\n    function interrupt(value) {\n       if (value.interrupt) {\n           value.interrupt.append = append;\n           value.interrupt.end = proceed;\n           value.interrupt = false;\n           append(true);\n           return true;\n       }\n       return false;\n    }\n\n    append(false, elem.indents\n        + (elem.name ? '<' + elem.name : '')\n        + (elem.attributes.length ? ' ' + elem.attributes.join(' ') : '')\n        + (len ? (elem.name ? '>' : '') : (elem.name ? '/>' : ''))\n        + (elem.indent && len > 1 ? '\\n' : ''));\n\n    if (!len) {\n        return append(false, elem.indent ? '\\n' : '');\n    }\n\n    if (!interrupt(elem)) {\n        proceed();\n    }\n}\n\nfunction attribute(key, value) {\n    return key + '=' + '\"' + escapeForXML(value) + '\"';\n}\n\nmodule.exports = xml;\nmodule.exports.element = module.exports.Element = element;\n\n\n//# sourceURL=webpack:///./node_modules/xml/lib/xml.js?");

/***/ }),

/***/ "./node_modules/xml2js/lib/bom.js":
/*!****************************************!*\
  !*** ./node_modules/xml2js/lib/bom.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  exports.stripBOM = function(str) {\n    if (str[0] === '\\uFEFF') {\n      return str.substring(1);\n    } else {\n      return str;\n    }\n  };\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xml2js/lib/bom.js?");

/***/ }),

/***/ "./node_modules/xml2js/lib/builder.js":
/*!********************************************!*\
  !*** ./node_modules/xml2js/lib/builder.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,\n    hasProp = {}.hasOwnProperty;\n\n  builder = __webpack_require__(/*! xmlbuilder */ \"./node_modules/xmlbuilder/lib/index.js\");\n\n  defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/xml2js/lib/defaults.js\").defaults;\n\n  requiresCDATA = function(entry) {\n    return typeof entry === \"string\" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);\n  };\n\n  wrapCDATA = function(entry) {\n    return \"<![CDATA[\" + (escapeCDATA(entry)) + \"]]>\";\n  };\n\n  escapeCDATA = function(entry) {\n    return entry.replace(']]>', ']]]]><![CDATA[>');\n  };\n\n  exports.Builder = (function() {\n    function Builder(opts) {\n      var key, ref, value;\n      this.options = {};\n      ref = defaults[\"0.2\"];\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n      }\n      for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n      }\n    }\n\n    Builder.prototype.buildObject = function(rootObj) {\n      var attrkey, charkey, render, rootElement, rootName;\n      attrkey = this.options.attrkey;\n      charkey = this.options.charkey;\n      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {\n        rootName = Object.keys(rootObj)[0];\n        rootObj = rootObj[rootName];\n      } else {\n        rootName = this.options.rootName;\n      }\n      render = (function(_this) {\n        return function(element, obj) {\n          var attr, child, entry, index, key, value;\n          if (typeof obj !== 'object') {\n            if (_this.options.cdata && requiresCDATA(obj)) {\n              element.raw(wrapCDATA(obj));\n            } else {\n              element.txt(obj);\n            }\n          } else if (Array.isArray(obj)) {\n            for (index in obj) {\n              if (!hasProp.call(obj, index)) continue;\n              child = obj[index];\n              for (key in child) {\n                entry = child[key];\n                element = render(element.ele(key), entry).up();\n              }\n            }\n          } else {\n            for (key in obj) {\n              if (!hasProp.call(obj, key)) continue;\n              child = obj[key];\n              if (key === attrkey) {\n                if (typeof child === \"object\") {\n                  for (attr in child) {\n                    value = child[attr];\n                    element = element.att(attr, value);\n                  }\n                }\n              } else if (key === charkey) {\n                if (_this.options.cdata && requiresCDATA(child)) {\n                  element = element.raw(wrapCDATA(child));\n                } else {\n                  element = element.txt(child);\n                }\n              } else if (Array.isArray(child)) {\n                for (index in child) {\n                  if (!hasProp.call(child, index)) continue;\n                  entry = child[index];\n                  if (typeof entry === 'string') {\n                    if (_this.options.cdata && requiresCDATA(entry)) {\n                      element = element.ele(key).raw(wrapCDATA(entry)).up();\n                    } else {\n                      element = element.ele(key, entry).up();\n                    }\n                  } else {\n                    element = render(element.ele(key), entry).up();\n                  }\n                }\n              } else if (typeof child === \"object\") {\n                element = render(element.ele(key), child).up();\n              } else {\n                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {\n                  element = element.ele(key).raw(wrapCDATA(child)).up();\n                } else {\n                  if (child == null) {\n                    child = '';\n                  }\n                  element = element.ele(key, child.toString()).up();\n                }\n              }\n            }\n          }\n          return element;\n        };\n      })(this);\n      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {\n        headless: this.options.headless,\n        allowSurrogateChars: this.options.allowSurrogateChars\n      });\n      return render(rootElement, rootObj).end(this.options.renderOpts);\n    };\n\n    return Builder;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xml2js/lib/builder.js?");

/***/ }),

/***/ "./node_modules/xml2js/lib/defaults.js":
/*!*********************************************!*\
  !*** ./node_modules/xml2js/lib/defaults.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  exports.defaults = {\n    \"0.1\": {\n      explicitCharkey: false,\n      trim: true,\n      normalize: true,\n      normalizeTags: false,\n      attrkey: \"@\",\n      charkey: \"#\",\n      explicitArray: false,\n      ignoreAttrs: false,\n      mergeAttrs: false,\n      explicitRoot: false,\n      validator: null,\n      xmlns: false,\n      explicitChildren: false,\n      childkey: '@@',\n      charsAsChildren: false,\n      includeWhiteChars: false,\n      async: false,\n      strict: true,\n      attrNameProcessors: null,\n      attrValueProcessors: null,\n      tagNameProcessors: null,\n      valueProcessors: null,\n      emptyTag: ''\n    },\n    \"0.2\": {\n      explicitCharkey: false,\n      trim: false,\n      normalize: false,\n      normalizeTags: false,\n      attrkey: \"$\",\n      charkey: \"_\",\n      explicitArray: true,\n      ignoreAttrs: false,\n      mergeAttrs: false,\n      explicitRoot: true,\n      validator: null,\n      xmlns: false,\n      explicitChildren: false,\n      preserveChildrenOrder: false,\n      childkey: '$$',\n      charsAsChildren: false,\n      includeWhiteChars: false,\n      async: false,\n      strict: true,\n      attrNameProcessors: null,\n      attrValueProcessors: null,\n      tagNameProcessors: null,\n      valueProcessors: null,\n      rootName: 'root',\n      xmldec: {\n        'version': '1.0',\n        'encoding': 'UTF-8',\n        'standalone': true\n      },\n      doctype: null,\n      renderOpts: {\n        'pretty': true,\n        'indent': '  ',\n        'newline': '\\n'\n      },\n      headless: false,\n      chunkSize: 10000,\n      emptyTag: '',\n      cdata: false\n    }\n  };\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xml2js/lib/defaults.js?");

/***/ }),

/***/ "./node_modules/xml2js/lib/parser.js":
/*!*******************************************!*\
  !*** ./node_modules/xml2js/lib/parser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  sax = __webpack_require__(/*! sax */ \"./node_modules/sax/lib/sax.js\");\n\n  events = __webpack_require__(/*! events */ \"events\");\n\n  bom = __webpack_require__(/*! ./bom */ \"./node_modules/xml2js/lib/bom.js\");\n\n  processors = __webpack_require__(/*! ./processors */ \"./node_modules/xml2js/lib/processors.js\");\n\n  setImmediate = __webpack_require__(/*! timers */ \"timers\").setImmediate;\n\n  defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/xml2js/lib/defaults.js\").defaults;\n\n  isEmpty = function(thing) {\n    return typeof thing === \"object\" && (thing != null) && Object.keys(thing).length === 0;\n  };\n\n  processItem = function(processors, item, key) {\n    var i, len, process;\n    for (i = 0, len = processors.length; i < len; i++) {\n      process = processors[i];\n      item = process(item, key);\n    }\n    return item;\n  };\n\n  exports.Parser = (function(superClass) {\n    extend(Parser, superClass);\n\n    function Parser(opts) {\n      this.parseString = bind(this.parseString, this);\n      this.reset = bind(this.reset, this);\n      this.assignOrPush = bind(this.assignOrPush, this);\n      this.processAsync = bind(this.processAsync, this);\n      var key, ref, value;\n      if (!(this instanceof exports.Parser)) {\n        return new exports.Parser(opts);\n      }\n      this.options = {};\n      ref = defaults[\"0.2\"];\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n      }\n      for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n      }\n      if (this.options.xmlns) {\n        this.options.xmlnskey = this.options.attrkey + \"ns\";\n      }\n      if (this.options.normalizeTags) {\n        if (!this.options.tagNameProcessors) {\n          this.options.tagNameProcessors = [];\n        }\n        this.options.tagNameProcessors.unshift(processors.normalize);\n      }\n      this.reset();\n    }\n\n    Parser.prototype.processAsync = function() {\n      var chunk, err;\n      try {\n        if (this.remaining.length <= this.options.chunkSize) {\n          chunk = this.remaining;\n          this.remaining = '';\n          this.saxParser = this.saxParser.write(chunk);\n          return this.saxParser.close();\n        } else {\n          chunk = this.remaining.substr(0, this.options.chunkSize);\n          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);\n          this.saxParser = this.saxParser.write(chunk);\n          return setImmediate(this.processAsync);\n        }\n      } catch (error1) {\n        err = error1;\n        if (!this.saxParser.errThrown) {\n          this.saxParser.errThrown = true;\n          return this.emit(err);\n        }\n      }\n    };\n\n    Parser.prototype.assignOrPush = function(obj, key, newValue) {\n      if (!(key in obj)) {\n        if (!this.options.explicitArray) {\n          return obj[key] = newValue;\n        } else {\n          return obj[key] = [newValue];\n        }\n      } else {\n        if (!(obj[key] instanceof Array)) {\n          obj[key] = [obj[key]];\n        }\n        return obj[key].push(newValue);\n      }\n    };\n\n    Parser.prototype.reset = function() {\n      var attrkey, charkey, ontext, stack;\n      this.removeAllListeners();\n      this.saxParser = sax.parser(this.options.strict, {\n        trim: false,\n        normalize: false,\n        xmlns: this.options.xmlns\n      });\n      this.saxParser.errThrown = false;\n      this.saxParser.onerror = (function(_this) {\n        return function(error) {\n          _this.saxParser.resume();\n          if (!_this.saxParser.errThrown) {\n            _this.saxParser.errThrown = true;\n            return _this.emit(\"error\", error);\n          }\n        };\n      })(this);\n      this.saxParser.onend = (function(_this) {\n        return function() {\n          if (!_this.saxParser.ended) {\n            _this.saxParser.ended = true;\n            return _this.emit(\"end\", _this.resultObject);\n          }\n        };\n      })(this);\n      this.saxParser.ended = false;\n      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;\n      this.resultObject = null;\n      stack = [];\n      attrkey = this.options.attrkey;\n      charkey = this.options.charkey;\n      this.saxParser.onopentag = (function(_this) {\n        return function(node) {\n          var key, newValue, obj, processedKey, ref;\n          obj = {};\n          obj[charkey] = \"\";\n          if (!_this.options.ignoreAttrs) {\n            ref = node.attributes;\n            for (key in ref) {\n              if (!hasProp.call(ref, key)) continue;\n              if (!(attrkey in obj) && !_this.options.mergeAttrs) {\n                obj[attrkey] = {};\n              }\n              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];\n              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;\n              if (_this.options.mergeAttrs) {\n                _this.assignOrPush(obj, processedKey, newValue);\n              } else {\n                obj[attrkey][processedKey] = newValue;\n              }\n            }\n          }\n          obj[\"#name\"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;\n          if (_this.options.xmlns) {\n            obj[_this.options.xmlnskey] = {\n              uri: node.uri,\n              local: node.local\n            };\n          }\n          return stack.push(obj);\n        };\n      })(this);\n      this.saxParser.onclosetag = (function(_this) {\n        return function() {\n          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;\n          obj = stack.pop();\n          nodeName = obj[\"#name\"];\n          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {\n            delete obj[\"#name\"];\n          }\n          if (obj.cdata === true) {\n            cdata = obj.cdata;\n            delete obj.cdata;\n          }\n          s = stack[stack.length - 1];\n          if (obj[charkey].match(/^\\s*$/) && !cdata) {\n            emptyStr = obj[charkey];\n            delete obj[charkey];\n          } else {\n            if (_this.options.trim) {\n              obj[charkey] = obj[charkey].trim();\n            }\n            if (_this.options.normalize) {\n              obj[charkey] = obj[charkey].replace(/\\s{2,}/g, \" \").trim();\n            }\n            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];\n            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {\n              obj = obj[charkey];\n            }\n          }\n          if (isEmpty(obj)) {\n            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;\n          }\n          if (_this.options.validator != null) {\n            xpath = \"/\" + ((function() {\n              var i, len, results;\n              results = [];\n              for (i = 0, len = stack.length; i < len; i++) {\n                node = stack[i];\n                results.push(node[\"#name\"]);\n              }\n              return results;\n            })()).concat(nodeName).join(\"/\");\n            (function() {\n              var err;\n              try {\n                return obj = _this.options.validator(xpath, s && s[nodeName], obj);\n              } catch (error1) {\n                err = error1;\n                return _this.emit(\"error\", err);\n              }\n            })();\n          }\n          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {\n            if (!_this.options.preserveChildrenOrder) {\n              node = {};\n              if (_this.options.attrkey in obj) {\n                node[_this.options.attrkey] = obj[_this.options.attrkey];\n                delete obj[_this.options.attrkey];\n              }\n              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {\n                node[_this.options.charkey] = obj[_this.options.charkey];\n                delete obj[_this.options.charkey];\n              }\n              if (Object.getOwnPropertyNames(obj).length > 0) {\n                node[_this.options.childkey] = obj;\n              }\n              obj = node;\n            } else if (s) {\n              s[_this.options.childkey] = s[_this.options.childkey] || [];\n              objClone = {};\n              for (key in obj) {\n                if (!hasProp.call(obj, key)) continue;\n                objClone[key] = obj[key];\n              }\n              s[_this.options.childkey].push(objClone);\n              delete obj[\"#name\"];\n              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {\n                obj = obj[charkey];\n              }\n            }\n          }\n          if (stack.length > 0) {\n            return _this.assignOrPush(s, nodeName, obj);\n          } else {\n            if (_this.options.explicitRoot) {\n              old = obj;\n              obj = {};\n              obj[nodeName] = old;\n            }\n            _this.resultObject = obj;\n            _this.saxParser.ended = true;\n            return _this.emit(\"end\", _this.resultObject);\n          }\n        };\n      })(this);\n      ontext = (function(_this) {\n        return function(text) {\n          var charChild, s;\n          s = stack[stack.length - 1];\n          if (s) {\n            s[charkey] += text;\n            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\\\n/g, '').trim() !== '')) {\n              s[_this.options.childkey] = s[_this.options.childkey] || [];\n              charChild = {\n                '#name': '__text__'\n              };\n              charChild[charkey] = text;\n              if (_this.options.normalize) {\n                charChild[charkey] = charChild[charkey].replace(/\\s{2,}/g, \" \").trim();\n              }\n              s[_this.options.childkey].push(charChild);\n            }\n            return s;\n          }\n        };\n      })(this);\n      this.saxParser.ontext = ontext;\n      return this.saxParser.oncdata = (function(_this) {\n        return function(text) {\n          var s;\n          s = ontext(text);\n          if (s) {\n            return s.cdata = true;\n          }\n        };\n      })(this);\n    };\n\n    Parser.prototype.parseString = function(str, cb) {\n      var err;\n      if ((cb != null) && typeof cb === \"function\") {\n        this.on(\"end\", function(result) {\n          this.reset();\n          return cb(null, result);\n        });\n        this.on(\"error\", function(err) {\n          this.reset();\n          return cb(err);\n        });\n      }\n      try {\n        str = str.toString();\n        if (str.trim() === '') {\n          this.emit(\"end\", null);\n          return true;\n        }\n        str = bom.stripBOM(str);\n        if (this.options.async) {\n          this.remaining = str;\n          setImmediate(this.processAsync);\n          return this.saxParser;\n        }\n        return this.saxParser.write(str).close();\n      } catch (error1) {\n        err = error1;\n        if (!(this.saxParser.errThrown || this.saxParser.ended)) {\n          this.emit('error', err);\n          return this.saxParser.errThrown = true;\n        } else if (this.saxParser.ended) {\n          throw err;\n        }\n      }\n    };\n\n    return Parser;\n\n  })(events.EventEmitter);\n\n  exports.parseString = function(str, a, b) {\n    var cb, options, parser;\n    if (b != null) {\n      if (typeof b === 'function') {\n        cb = b;\n      }\n      if (typeof a === 'object') {\n        options = a;\n      }\n    } else {\n      if (typeof a === 'function') {\n        cb = a;\n      }\n      options = {};\n    }\n    parser = new exports.Parser(options);\n    return parser.parseString(str, cb);\n  };\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xml2js/lib/parser.js?");

/***/ }),

/***/ "./node_modules/xml2js/lib/processors.js":
/*!***********************************************!*\
  !*** ./node_modules/xml2js/lib/processors.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var prefixMatch;\n\n  prefixMatch = new RegExp(/(?!xmlns)^.*:/);\n\n  exports.normalize = function(str) {\n    return str.toLowerCase();\n  };\n\n  exports.firstCharLowerCase = function(str) {\n    return str.charAt(0).toLowerCase() + str.slice(1);\n  };\n\n  exports.stripPrefix = function(str) {\n    return str.replace(prefixMatch, '');\n  };\n\n  exports.parseNumbers = function(str) {\n    if (!isNaN(str)) {\n      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);\n    }\n    return str;\n  };\n\n  exports.parseBooleans = function(str) {\n    if (/^(?:true|false)$/i.test(str)) {\n      str = str.toLowerCase() === 'true';\n    }\n    return str;\n  };\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xml2js/lib/processors.js?");

/***/ }),

/***/ "./node_modules/xml2js/lib/xml2js.js":
/*!*******************************************!*\
  !*** ./node_modules/xml2js/lib/xml2js.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var builder, defaults, parser, processors,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/xml2js/lib/defaults.js\");\n\n  builder = __webpack_require__(/*! ./builder */ \"./node_modules/xml2js/lib/builder.js\");\n\n  parser = __webpack_require__(/*! ./parser */ \"./node_modules/xml2js/lib/parser.js\");\n\n  processors = __webpack_require__(/*! ./processors */ \"./node_modules/xml2js/lib/processors.js\");\n\n  exports.defaults = defaults.defaults;\n\n  exports.processors = processors;\n\n  exports.ValidationError = (function(superClass) {\n    extend(ValidationError, superClass);\n\n    function ValidationError(message) {\n      this.message = message;\n    }\n\n    return ValidationError;\n\n  })(Error);\n\n  exports.Builder = builder.Builder;\n\n  exports.Parser = parser.Parser;\n\n  exports.parseString = parser.parseString;\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xml2js/lib/xml2js.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/Utility.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/Utility.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var assign, isArray, isEmpty, isFunction, isObject, isPlainObject,\n    slice = [].slice,\n    hasProp = {}.hasOwnProperty;\n\n  assign = function() {\n    var i, key, len, source, sources, target;\n    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    if (isFunction(Object.assign)) {\n      Object.assign.apply(null, arguments);\n    } else {\n      for (i = 0, len = sources.length; i < len; i++) {\n        source = sources[i];\n        if (source != null) {\n          for (key in source) {\n            if (!hasProp.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n\n  isFunction = function(val) {\n    return !!val && Object.prototype.toString.call(val) === '[object Function]';\n  };\n\n  isObject = function(val) {\n    var ref;\n    return !!val && ((ref = typeof val) === 'function' || ref === 'object');\n  };\n\n  isArray = function(val) {\n    if (isFunction(Array.isArray)) {\n      return Array.isArray(val);\n    } else {\n      return Object.prototype.toString.call(val) === '[object Array]';\n    }\n  };\n\n  isEmpty = function(val) {\n    var key;\n    if (isArray(val)) {\n      return !val.length;\n    } else {\n      for (key in val) {\n        if (!hasProp.call(val, key)) continue;\n        return false;\n      }\n      return true;\n    }\n  };\n\n  isPlainObject = function(val) {\n    var ctor, proto;\n    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));\n  };\n\n  module.exports.assign = assign;\n\n  module.exports.isFunction = isFunction;\n\n  module.exports.isObject = isObject;\n\n  module.exports.isArray = isArray;\n\n  module.exports.isEmpty = isEmpty;\n\n  module.exports.isPlainObject = isPlainObject;\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/Utility.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLAttribute.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLAttribute.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLAttribute;\n\n  module.exports = XMLAttribute = (function() {\n    function XMLAttribute(parent, name, value) {\n      this.options = parent.options;\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error(\"Missing attribute name of element \" + parent.name);\n      }\n      if (value == null) {\n        throw new Error(\"Missing attribute value for attribute \" + name + \" of element \" + parent.name);\n      }\n      this.name = this.stringify.attName(name);\n      this.value = this.stringify.attValue(value);\n    }\n\n    XMLAttribute.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLAttribute.prototype.toString = function(options) {\n      return this.options.writer.set(options).attribute(this);\n    };\n\n    return XMLAttribute;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLAttribute.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLCData.js":
/*!*************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLCData.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCData, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLCData = (function(superClass) {\n    extend(XMLCData, superClass);\n\n    function XMLCData(parent, text) {\n      XMLCData.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing CDATA text\");\n      }\n      this.text = this.stringify.cdata(text);\n    }\n\n    XMLCData.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLCData.prototype.toString = function(options) {\n      return this.options.writer.set(options).cdata(this);\n    };\n\n    return XMLCData;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLCData.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLComment.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLComment.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLComment, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLComment = (function(superClass) {\n    extend(XMLComment, superClass);\n\n    function XMLComment(parent, text) {\n      XMLComment.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing comment text\");\n      }\n      this.text = this.stringify.comment(text);\n    }\n\n    XMLComment.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLComment.prototype.toString = function(options) {\n      return this.options.writer.set(options).comment(this);\n    };\n\n    return XMLComment;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLComment.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDAttList.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDAttList, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDTDAttList = (function(superClass) {\n    extend(XMLDTDAttList, superClass);\n\n    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      XMLDTDAttList.__super__.constructor.call(this, parent);\n      if (elementName == null) {\n        throw new Error(\"Missing DTD element name\");\n      }\n      if (attributeName == null) {\n        throw new Error(\"Missing DTD attribute name\");\n      }\n      if (!attributeType) {\n        throw new Error(\"Missing DTD attribute type\");\n      }\n      if (!defaultValueType) {\n        throw new Error(\"Missing DTD attribute default\");\n      }\n      if (defaultValueType.indexOf('#') !== 0) {\n        defaultValueType = '#' + defaultValueType;\n      }\n      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT\");\n      }\n      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Default value only applies to #FIXED or #DEFAULT\");\n      }\n      this.elementName = this.stringify.eleName(elementName);\n      this.attributeName = this.stringify.attName(attributeName);\n      this.attributeType = this.stringify.dtdAttType(attributeType);\n      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n      this.defaultValueType = defaultValueType;\n    }\n\n    XMLDTDAttList.prototype.toString = function(options) {\n      return this.options.writer.set(options).dtdAttList(this);\n    };\n\n    return XMLDTDAttList;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLDTDAttList.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDElement.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDElement.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDElement, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDTDElement = (function(superClass) {\n    extend(XMLDTDElement, superClass);\n\n    function XMLDTDElement(parent, name, value) {\n      XMLDTDElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing DTD element name\");\n      }\n      if (!value) {\n        value = '(#PCDATA)';\n      }\n      if (Array.isArray(value)) {\n        value = '(' + value.join(',') + ')';\n      }\n      this.name = this.stringify.eleName(name);\n      this.value = this.stringify.dtdElementValue(value);\n    }\n\n    XMLDTDElement.prototype.toString = function(options) {\n      return this.options.writer.set(options).dtdElement(this);\n    };\n\n    return XMLDTDElement;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLDTDElement.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDEntity.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDEntity, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\").isObject;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDTDEntity = (function(superClass) {\n    extend(XMLDTDEntity, superClass);\n\n    function XMLDTDEntity(parent, pe, name, value) {\n      XMLDTDEntity.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing entity name\");\n      }\n      if (value == null) {\n        throw new Error(\"Missing entity value\");\n      }\n      this.pe = !!pe;\n      this.name = this.stringify.eleName(name);\n      if (!isObject(value)) {\n        this.value = this.stringify.dtdEntityValue(value);\n      } else {\n        if (!value.pubID && !value.sysID) {\n          throw new Error(\"Public and/or system identifiers are required for an external entity\");\n        }\n        if (value.pubID && !value.sysID) {\n          throw new Error(\"System identifier is required for a public external entity\");\n        }\n        if (value.pubID != null) {\n          this.pubID = this.stringify.dtdPubID(value.pubID);\n        }\n        if (value.sysID != null) {\n          this.sysID = this.stringify.dtdSysID(value.sysID);\n        }\n        if (value.nData != null) {\n          this.nData = this.stringify.dtdNData(value.nData);\n        }\n        if (this.pe && this.nData) {\n          throw new Error(\"Notation declaration is not allowed in a parameter entity\");\n        }\n      }\n    }\n\n    XMLDTDEntity.prototype.toString = function(options) {\n      return this.options.writer.set(options).dtdEntity(this);\n    };\n\n    return XMLDTDEntity;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLDTDEntity.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDNotation.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDNotation, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDTDNotation = (function(superClass) {\n    extend(XMLDTDNotation, superClass);\n\n    function XMLDTDNotation(parent, name, value) {\n      XMLDTDNotation.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing notation name\");\n      }\n      if (!value.pubID && !value.sysID) {\n        throw new Error(\"Public or system identifiers are required for an external entity\");\n      }\n      this.name = this.stringify.eleName(name);\n      if (value.pubID != null) {\n        this.pubID = this.stringify.dtdPubID(value.pubID);\n      }\n      if (value.sysID != null) {\n        this.sysID = this.stringify.dtdSysID(value.sysID);\n      }\n    }\n\n    XMLDTDNotation.prototype.toString = function(options) {\n      return this.options.writer.set(options).dtdNotation(this);\n    };\n\n    return XMLDTDNotation;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLDTDNotation.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDeclaration.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDeclaration.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDeclaration, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\").isObject;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDeclaration = (function(superClass) {\n    extend(XMLDeclaration, superClass);\n\n    function XMLDeclaration(parent, version, encoding, standalone) {\n      var ref;\n      XMLDeclaration.__super__.constructor.call(this, parent);\n      if (isObject(version)) {\n        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n      }\n      if (!version) {\n        version = '1.0';\n      }\n      this.version = this.stringify.xmlVersion(version);\n      if (encoding != null) {\n        this.encoding = this.stringify.xmlEncoding(encoding);\n      }\n      if (standalone != null) {\n        this.standalone = this.stringify.xmlStandalone(standalone);\n      }\n    }\n\n    XMLDeclaration.prototype.toString = function(options) {\n      return this.options.writer.set(options).declaration(this);\n    };\n\n    return XMLDeclaration;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLDeclaration.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocType.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocType.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\").isObject;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ \"./node_modules/xmlbuilder/lib/XMLDTDAttList.js\");\n\n  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ \"./node_modules/xmlbuilder/lib/XMLDTDEntity.js\");\n\n  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ \"./node_modules/xmlbuilder/lib/XMLDTDElement.js\");\n\n  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ \"./node_modules/xmlbuilder/lib/XMLDTDNotation.js\");\n\n  module.exports = XMLDocType = (function(superClass) {\n    extend(XMLDocType, superClass);\n\n    function XMLDocType(parent, pubID, sysID) {\n      var ref, ref1;\n      XMLDocType.__super__.constructor.call(this, parent);\n      this.documentObject = parent;\n      if (isObject(pubID)) {\n        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;\n      }\n      if (sysID == null) {\n        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];\n      }\n      if (pubID != null) {\n        this.pubID = this.stringify.dtdPubID(pubID);\n      }\n      if (sysID != null) {\n        this.sysID = this.stringify.dtdSysID(sysID);\n      }\n    }\n\n    XMLDocType.prototype.element = function(name, value) {\n      var child;\n      child = new XMLDTDElement(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var child;\n      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.entity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, false, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.pEntity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, true, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.notation = function(name, value) {\n      var child;\n      child = new XMLDTDNotation(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.toString = function(options) {\n      return this.options.writer.set(options).docType(this);\n    };\n\n    XMLDocType.prototype.ele = function(name, value) {\n      return this.element(name, value);\n    };\n\n    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);\n    };\n\n    XMLDocType.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocType.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocType.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    XMLDocType.prototype.up = function() {\n      return this.root() || this.documentObject;\n    };\n\n    return XMLDocType;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLDocType.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocument.js":
/*!****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocument.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isPlainObject = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\").isPlainObject;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ \"./node_modules/xmlbuilder/lib/XMLStringifier.js\");\n\n  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ \"./node_modules/xmlbuilder/lib/XMLStringWriter.js\");\n\n  module.exports = XMLDocument = (function(superClass) {\n    extend(XMLDocument, superClass);\n\n    function XMLDocument(options) {\n      XMLDocument.__super__.constructor.call(this, null);\n      options || (options = {});\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.stringify = new XMLStringifier(options);\n      this.isDocument = true;\n    }\n\n    XMLDocument.prototype.end = function(writer) {\n      var writerOptions;\n      if (!writer) {\n        writer = this.options.writer;\n      } else if (isPlainObject(writer)) {\n        writerOptions = writer;\n        writer = this.options.writer.set(writerOptions);\n      }\n      return writer.document(this);\n    };\n\n    XMLDocument.prototype.toString = function(options) {\n      return this.options.writer.set(options).document(this);\n    };\n\n    return XMLDocument;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLDocument.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocumentCB.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocumentCB.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref,\n    hasProp = {}.hasOwnProperty;\n\n  ref = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\"), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;\n\n  XMLElement = __webpack_require__(/*! ./XMLElement */ \"./node_modules/xmlbuilder/lib/XMLElement.js\");\n\n  XMLCData = __webpack_require__(/*! ./XMLCData */ \"./node_modules/xmlbuilder/lib/XMLCData.js\");\n\n  XMLComment = __webpack_require__(/*! ./XMLComment */ \"./node_modules/xmlbuilder/lib/XMLComment.js\");\n\n  XMLRaw = __webpack_require__(/*! ./XMLRaw */ \"./node_modules/xmlbuilder/lib/XMLRaw.js\");\n\n  XMLText = __webpack_require__(/*! ./XMLText */ \"./node_modules/xmlbuilder/lib/XMLText.js\");\n\n  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n\n  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"./node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n\n  XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"./node_modules/xmlbuilder/lib/XMLDocType.js\");\n\n  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ \"./node_modules/xmlbuilder/lib/XMLDTDAttList.js\");\n\n  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ \"./node_modules/xmlbuilder/lib/XMLDTDEntity.js\");\n\n  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ \"./node_modules/xmlbuilder/lib/XMLDTDElement.js\");\n\n  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ \"./node_modules/xmlbuilder/lib/XMLDTDNotation.js\");\n\n  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ \"./node_modules/xmlbuilder/lib/XMLAttribute.js\");\n\n  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ \"./node_modules/xmlbuilder/lib/XMLStringifier.js\");\n\n  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ \"./node_modules/xmlbuilder/lib/XMLStringWriter.js\");\n\n  module.exports = XMLDocumentCB = (function() {\n    function XMLDocumentCB(options, onData, onEnd) {\n      var writerOptions;\n      options || (options = {});\n      if (!options.writer) {\n        options.writer = new XMLStringWriter(options);\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter(writerOptions);\n      }\n      this.options = options;\n      this.writer = options.writer;\n      this.stringify = new XMLStringifier(options);\n      this.onDataCallback = onData || function() {};\n      this.onEndCallback = onEnd || function() {};\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    }\n\n    XMLDocumentCB.prototype.node = function(name, attributes, text) {\n      var ref1;\n      if (name == null) {\n        throw new Error(\"Missing node name\");\n      }\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node\");\n      }\n      this.openCurrent();\n      name = name.valueOf();\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];\n      }\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      if (text != null) {\n        this.text(text);\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.element = function(name, attributes, text) {\n      if (this.currentNode && this.currentNode instanceof XMLDocType) {\n        return this.dtdElement.apply(this, arguments);\n      } else {\n        return this.node(name, attributes, text);\n      }\n    };\n\n    XMLDocumentCB.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode\");\n      }\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (!this.options.skipNullAttributes || (value != null)) {\n          this.currentNode.attributes[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.text = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.cdata = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.comment = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.raw = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.instruction = function(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n      if (target != null) {\n        target = target.valueOf();\n      }\n      if (value != null) {\n        value = value.valueOf();\n      }\n      if (Array.isArray(target)) {\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node\");\n      }\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {\n      this.openCurrent();\n      if (root == null) {\n        throw new Error(\"Missing root node name\");\n      }\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node\");\n      }\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    };\n\n    XMLDocumentCB.prototype.dtdElement = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.entity = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.pEntity = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.notation = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.up = function() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent\");\n      }\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    };\n\n    XMLDocumentCB.prototype.end = function() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n      return this.onEnd();\n    };\n\n    XMLDocumentCB.prototype.openCurrent = function() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    };\n\n    XMLDocumentCB.prototype.openNode = function(node) {\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {\n          this.root = node;\n        }\n        this.onData(this.writer.openNode(node, this.currentLevel));\n        return node.isOpen = true;\n      }\n    };\n\n    XMLDocumentCB.prototype.closeNode = function(node) {\n      if (!node.isClosed) {\n        this.onData(this.writer.closeNode(node, this.currentLevel));\n        return node.isClosed = true;\n      }\n    };\n\n    XMLDocumentCB.prototype.onData = function(chunk) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk);\n    };\n\n    XMLDocumentCB.prototype.onEnd = function() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    };\n\n    XMLDocumentCB.prototype.ele = function() {\n      return this.element.apply(this, arguments);\n    };\n\n    XMLDocumentCB.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLDocumentCB.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocumentCB.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocumentCB.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    };\n\n    XMLDocumentCB.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLDocumentCB.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocumentCB.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocumentCB.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLDocumentCB.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocumentCB.prototype.att = function() {\n      if (this.currentNode && this.currentNode instanceof XMLDocType) {\n        return this.attList.apply(this, arguments);\n      } else {\n        return this.attribute.apply(this, arguments);\n      }\n    };\n\n    XMLDocumentCB.prototype.a = function() {\n      if (this.currentNode && this.currentNode instanceof XMLDocType) {\n        return this.attList.apply(this, arguments);\n      } else {\n        return this.attribute.apply(this, arguments);\n      }\n    };\n\n    XMLDocumentCB.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocumentCB.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocumentCB.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    return XMLDocumentCB;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLDocumentCB.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLElement.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLElement.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  ref = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\"), isObject = ref.isObject, isFunction = ref.isFunction;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ \"./node_modules/xmlbuilder/lib/XMLAttribute.js\");\n\n  module.exports = XMLElement = (function(superClass) {\n    extend(XMLElement, superClass);\n\n    function XMLElement(parent, name, attributes) {\n      XMLElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing element name\");\n      }\n      this.name = this.stringify.eleName(name);\n      this.attributes = {};\n      if (attributes != null) {\n        this.attribute(attributes);\n      }\n      if (parent.isDocument) {\n        this.isRoot = true;\n        this.documentObject = parent;\n        parent.rootObject = this;\n      }\n    }\n\n    XMLElement.prototype.clone = function() {\n      var att, attName, clonedSelf, ref1;\n      clonedSelf = Object.create(this);\n      if (clonedSelf.isRoot) {\n        clonedSelf.documentObject = null;\n      }\n      clonedSelf.attributes = {};\n      ref1 = this.attributes;\n      for (attName in ref1) {\n        if (!hasProp.call(ref1, attName)) continue;\n        att = ref1[attName];\n        clonedSelf.attributes[attName] = att.clone();\n      }\n      clonedSelf.children = [];\n      this.children.forEach(function(child) {\n        var clonedChild;\n        clonedChild = child.clone();\n        clonedChild.parent = clonedSelf;\n        return clonedSelf.children.push(clonedChild);\n      });\n      return clonedSelf;\n    };\n\n    XMLElement.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (!this.options.skipNullAttributes || (value != null)) {\n          this.attributes[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLElement.prototype.removeAttribute = function(name) {\n      var attName, i, len;\n      if (name == null) {\n        throw new Error(\"Missing attribute name\");\n      }\n      name = name.valueOf();\n      if (Array.isArray(name)) {\n        for (i = 0, len = name.length; i < len; i++) {\n          attName = name[i];\n          delete this.attributes[attName];\n        }\n      } else {\n        delete this.attributes[name];\n      }\n      return this;\n    };\n\n    XMLElement.prototype.toString = function(options) {\n      return this.options.writer.set(options).element(this);\n    };\n\n    XMLElement.prototype.att = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.a = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    return XMLElement;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLElement.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLNode.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLNode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref,\n    hasProp = {}.hasOwnProperty;\n\n  ref = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\"), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  XMLProcessingInstruction = null;\n\n  module.exports = XMLNode = (function() {\n    function XMLNode(parent) {\n      this.parent = parent;\n      if (this.parent) {\n        this.options = this.parent.options;\n        this.stringify = this.parent.stringify;\n      }\n      this.children = [];\n      if (!XMLElement) {\n        XMLElement = __webpack_require__(/*! ./XMLElement */ \"./node_modules/xmlbuilder/lib/XMLElement.js\");\n        XMLCData = __webpack_require__(/*! ./XMLCData */ \"./node_modules/xmlbuilder/lib/XMLCData.js\");\n        XMLComment = __webpack_require__(/*! ./XMLComment */ \"./node_modules/xmlbuilder/lib/XMLComment.js\");\n        XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"./node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n        XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"./node_modules/xmlbuilder/lib/XMLDocType.js\");\n        XMLRaw = __webpack_require__(/*! ./XMLRaw */ \"./node_modules/xmlbuilder/lib/XMLRaw.js\");\n        XMLText = __webpack_require__(/*! ./XMLText */ \"./node_modules/xmlbuilder/lib/XMLText.js\");\n        XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n      }\n    }\n\n    XMLNode.prototype.element = function(name, attributes, text) {\n      var childNode, item, j, k, key, lastChild, len, len1, ref1, val;\n      lastChild = null;\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];\n      }\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (Array.isArray(name)) {\n        for (j = 0, len = name.length; j < len; j++) {\n          item = name[j];\n          lastChild = this.element(item);\n        }\n      } else if (isFunction(name)) {\n        lastChild = this.element(name.apply());\n      } else if (isObject(name)) {\n        for (key in name) {\n          if (!hasProp.call(name, key)) continue;\n          val = name[key];\n          if (isFunction(val)) {\n            val = val.apply();\n          }\n          if ((isObject(val)) && (isEmpty(val))) {\n            val = null;\n          }\n          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n          } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n            for (k = 0, len1 = val.length; k < len1; k++) {\n              item = val[k];\n              childNode = {};\n              childNode[key] = item;\n              lastChild = this.element(childNode);\n            }\n          } else if (isObject(val)) {\n            lastChild = this.element(key);\n            lastChild.element(val);\n          } else {\n            lastChild = this.element(key, val);\n          }\n        }\n      } else {\n        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n          lastChild = this.text(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n          lastChild = this.cdata(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n          lastChild = this.comment(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n          lastChild = this.raw(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n        } else {\n          lastChild = this.node(name, attributes, text);\n        }\n      }\n      if (lastChild == null) {\n        throw new Error(\"Could not create any elements with: \" + name);\n      }\n      return lastChild;\n    };\n\n    XMLNode.prototype.insertBefore = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error(\"Cannot insert elements at root level\");\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.insertAfter = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error(\"Cannot insert elements at root level\");\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.remove = function() {\n      var i, ref1;\n      if (this.isRoot) {\n        throw new Error(\"Cannot remove the root element\");\n      }\n      i = this.parent.children.indexOf(this);\n      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n      return this.parent;\n    };\n\n    XMLNode.prototype.node = function(name, attributes, text) {\n      var child, ref1;\n      if (name != null) {\n        name = name.valueOf();\n      }\n      attributes || (attributes = {});\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];\n      }\n      child = new XMLElement(this, name, attributes);\n      if (text != null) {\n        child.text(text);\n      }\n      this.children.push(child);\n      return child;\n    };\n\n    XMLNode.prototype.text = function(value) {\n      var child;\n      child = new XMLText(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.cdata = function(value) {\n      var child;\n      child = new XMLCData(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.comment = function(value) {\n      var child;\n      child = new XMLComment(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.commentBefore = function(value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.comment(value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.commentAfter = function(value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.comment(value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.raw = function(value) {\n      var child;\n      child = new XMLRaw(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.instruction = function(target, value) {\n      var insTarget, insValue, instruction, j, len;\n      if (target != null) {\n        target = target.valueOf();\n      }\n      if (value != null) {\n        value = value.valueOf();\n      }\n      if (Array.isArray(target)) {\n        for (j = 0, len = target.length; j < len; j++) {\n          insTarget = target[j];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        instruction = new XMLProcessingInstruction(this, target, value);\n        this.children.push(instruction);\n      }\n      return this;\n    };\n\n    XMLNode.prototype.instructionBefore = function(target, value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.instruction(target, value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.instructionAfter = function(target, value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.instruction(target, value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.declaration = function(version, encoding, standalone) {\n      var doc, xmldec;\n      doc = this.document();\n      xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n      if (doc.children[0] instanceof XMLDeclaration) {\n        doc.children[0] = xmldec;\n      } else {\n        doc.children.unshift(xmldec);\n      }\n      return doc.root() || doc;\n    };\n\n    XMLNode.prototype.doctype = function(pubID, sysID) {\n      var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n      doc = this.document();\n      doctype = new XMLDocType(doc, pubID, sysID);\n      ref1 = doc.children;\n      for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n        child = ref1[i];\n        if (child instanceof XMLDocType) {\n          doc.children[i] = doctype;\n          return doctype;\n        }\n      }\n      ref2 = doc.children;\n      for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n        child = ref2[i];\n        if (child.isRoot) {\n          doc.children.splice(i, 0, doctype);\n          return doctype;\n        }\n      }\n      doc.children.push(doctype);\n      return doctype;\n    };\n\n    XMLNode.prototype.up = function() {\n      if (this.isRoot) {\n        throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n      }\n      return this.parent;\n    };\n\n    XMLNode.prototype.root = function() {\n      var node;\n      node = this;\n      while (node) {\n        if (node.isDocument) {\n          return node.rootObject;\n        } else if (node.isRoot) {\n          return node;\n        } else {\n          node = node.parent;\n        }\n      }\n    };\n\n    XMLNode.prototype.document = function() {\n      var node;\n      node = this;\n      while (node) {\n        if (node.isDocument) {\n          return node;\n        } else {\n          node = node.parent;\n        }\n      }\n    };\n\n    XMLNode.prototype.end = function(options) {\n      return this.document().end(options);\n    };\n\n    XMLNode.prototype.prev = function() {\n      var i;\n      i = this.parent.children.indexOf(this);\n      if (i < 1) {\n        throw new Error(\"Already at the first node\");\n      }\n      return this.parent.children[i - 1];\n    };\n\n    XMLNode.prototype.next = function() {\n      var i;\n      i = this.parent.children.indexOf(this);\n      if (i === -1 || i === this.parent.children.length - 1) {\n        throw new Error(\"Already at the last node\");\n      }\n      return this.parent.children[i + 1];\n    };\n\n    XMLNode.prototype.importDocument = function(doc) {\n      var clonedRoot;\n      clonedRoot = doc.root().clone();\n      clonedRoot.parent = this;\n      clonedRoot.isRoot = false;\n      this.children.push(clonedRoot);\n      return this;\n    };\n\n    XMLNode.prototype.ele = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLNode.prototype.doc = function() {\n      return this.document();\n    };\n\n    XMLNode.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLNode.prototype.dtd = function(pubID, sysID) {\n      return this.doctype(pubID, sysID);\n    };\n\n    XMLNode.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLNode.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLNode.prototype.u = function() {\n      return this.up();\n    };\n\n    XMLNode.prototype.importXMLBuilder = function(doc) {\n      return this.importDocument(doc);\n    };\n\n    return XMLNode;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLNode.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNode, XMLProcessingInstruction,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLProcessingInstruction = (function(superClass) {\n    extend(XMLProcessingInstruction, superClass);\n\n    function XMLProcessingInstruction(parent, target, value) {\n      XMLProcessingInstruction.__super__.constructor.call(this, parent);\n      if (target == null) {\n        throw new Error(\"Missing instruction target\");\n      }\n      this.target = this.stringify.insTarget(target);\n      if (value) {\n        this.value = this.stringify.insValue(value);\n      }\n    }\n\n    XMLProcessingInstruction.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLProcessingInstruction.prototype.toString = function(options) {\n      return this.options.writer.set(options).processingInstruction(this);\n    };\n\n    return XMLProcessingInstruction;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLRaw.js":
/*!***********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLRaw.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNode, XMLRaw,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLRaw = (function(superClass) {\n    extend(XMLRaw, superClass);\n\n    function XMLRaw(parent, text) {\n      XMLRaw.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing raw text\");\n      }\n      this.value = this.stringify.raw(text);\n    }\n\n    XMLRaw.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLRaw.prototype.toString = function(options) {\n      return this.options.writer.set(options).raw(this);\n    };\n\n    return XMLRaw;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLRaw.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStreamWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStreamWriter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"./node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n\n  XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"./node_modules/xmlbuilder/lib/XMLDocType.js\");\n\n  XMLCData = __webpack_require__(/*! ./XMLCData */ \"./node_modules/xmlbuilder/lib/XMLCData.js\");\n\n  XMLComment = __webpack_require__(/*! ./XMLComment */ \"./node_modules/xmlbuilder/lib/XMLComment.js\");\n\n  XMLElement = __webpack_require__(/*! ./XMLElement */ \"./node_modules/xmlbuilder/lib/XMLElement.js\");\n\n  XMLRaw = __webpack_require__(/*! ./XMLRaw */ \"./node_modules/xmlbuilder/lib/XMLRaw.js\");\n\n  XMLText = __webpack_require__(/*! ./XMLText */ \"./node_modules/xmlbuilder/lib/XMLText.js\");\n\n  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n\n  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ \"./node_modules/xmlbuilder/lib/XMLDTDAttList.js\");\n\n  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ \"./node_modules/xmlbuilder/lib/XMLDTDElement.js\");\n\n  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ \"./node_modules/xmlbuilder/lib/XMLDTDEntity.js\");\n\n  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ \"./node_modules/xmlbuilder/lib/XMLDTDNotation.js\");\n\n  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ \"./node_modules/xmlbuilder/lib/XMLWriterBase.js\");\n\n  module.exports = XMLStreamWriter = (function(superClass) {\n    extend(XMLStreamWriter, superClass);\n\n    function XMLStreamWriter(stream, options) {\n      XMLStreamWriter.__super__.constructor.call(this, options);\n      this.stream = stream;\n    }\n\n    XMLStreamWriter.prototype.document = function(doc) {\n      var child, i, j, len, len1, ref, ref1, results;\n      ref = doc.children;\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        child.isLastRootNode = false;\n      }\n      doc.children[doc.children.length - 1].isLastRootNode = true;\n      ref1 = doc.children;\n      results = [];\n      for (j = 0, len1 = ref1.length; j < len1; j++) {\n        child = ref1[j];\n        switch (false) {\n          case !(child instanceof XMLDeclaration):\n            results.push(this.declaration(child));\n            break;\n          case !(child instanceof XMLDocType):\n            results.push(this.docType(child));\n            break;\n          case !(child instanceof XMLComment):\n            results.push(this.comment(child));\n            break;\n          case !(child instanceof XMLProcessingInstruction):\n            results.push(this.processingInstruction(child));\n            break;\n          default:\n            results.push(this.element(child));\n        }\n      }\n      return results;\n    };\n\n    XMLStreamWriter.prototype.attribute = function(att) {\n      return this.stream.write(' ' + att.name + '=\"' + att.value + '\"');\n    };\n\n    XMLStreamWriter.prototype.cdata = function(node, level) {\n      return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.comment = function(node, level) {\n      return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.declaration = function(node, level) {\n      this.stream.write(this.space(level));\n      this.stream.write('<?xml version=\"' + node.version + '\"');\n      if (node.encoding != null) {\n        this.stream.write(' encoding=\"' + node.encoding + '\"');\n      }\n      if (node.standalone != null) {\n        this.stream.write(' standalone=\"' + node.standalone + '\"');\n      }\n      this.stream.write(this.spacebeforeslash + '?>');\n      return this.stream.write(this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.docType = function(node, level) {\n      var child, i, len, ref;\n      level || (level = 0);\n      this.stream.write(this.space(level));\n      this.stream.write('<!DOCTYPE ' + node.root().name);\n      if (node.pubID && node.sysID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n      } else if (node.sysID) {\n        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n      }\n      if (node.children.length > 0) {\n        this.stream.write(' [');\n        this.stream.write(this.endline(node));\n        ref = node.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          switch (false) {\n            case !(child instanceof XMLDTDAttList):\n              this.dtdAttList(child, level + 1);\n              break;\n            case !(child instanceof XMLDTDElement):\n              this.dtdElement(child, level + 1);\n              break;\n            case !(child instanceof XMLDTDEntity):\n              this.dtdEntity(child, level + 1);\n              break;\n            case !(child instanceof XMLDTDNotation):\n              this.dtdNotation(child, level + 1);\n              break;\n            case !(child instanceof XMLCData):\n              this.cdata(child, level + 1);\n              break;\n            case !(child instanceof XMLComment):\n              this.comment(child, level + 1);\n              break;\n            case !(child instanceof XMLProcessingInstruction):\n              this.processingInstruction(child, level + 1);\n              break;\n            default:\n              throw new Error(\"Unknown DTD node type: \" + child.constructor.name);\n          }\n        }\n        this.stream.write(']');\n      }\n      this.stream.write(this.spacebeforeslash + '>');\n      return this.stream.write(this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.element = function(node, level) {\n      var att, child, i, len, name, ref, ref1, space;\n      level || (level = 0);\n      space = this.space(level);\n      this.stream.write(space + '<' + node.name);\n      ref = node.attributes;\n      for (name in ref) {\n        if (!hasProp.call(ref, name)) continue;\n        att = ref[name];\n        this.attribute(att);\n      }\n      if (node.children.length === 0 || node.children.every(function(e) {\n        return e.value === '';\n      })) {\n        if (this.allowEmpty) {\n          this.stream.write('></' + node.name + '>');\n        } else {\n          this.stream.write(this.spacebeforeslash + '/>');\n        }\n      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {\n        this.stream.write('>');\n        this.stream.write(node.children[0].value);\n        this.stream.write('</' + node.name + '>');\n      } else {\n        this.stream.write('>' + this.newline);\n        ref1 = node.children;\n        for (i = 0, len = ref1.length; i < len; i++) {\n          child = ref1[i];\n          switch (false) {\n            case !(child instanceof XMLCData):\n              this.cdata(child, level + 1);\n              break;\n            case !(child instanceof XMLComment):\n              this.comment(child, level + 1);\n              break;\n            case !(child instanceof XMLElement):\n              this.element(child, level + 1);\n              break;\n            case !(child instanceof XMLRaw):\n              this.raw(child, level + 1);\n              break;\n            case !(child instanceof XMLText):\n              this.text(child, level + 1);\n              break;\n            case !(child instanceof XMLProcessingInstruction):\n              this.processingInstruction(child, level + 1);\n              break;\n            default:\n              throw new Error(\"Unknown XML node type: \" + child.constructor.name);\n          }\n        }\n        this.stream.write(space + '</' + node.name + '>');\n      }\n      return this.stream.write(this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.processingInstruction = function(node, level) {\n      this.stream.write(this.space(level) + '<?' + node.target);\n      if (node.value) {\n        this.stream.write(' ' + node.value);\n      }\n      return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.raw = function(node, level) {\n      return this.stream.write(this.space(level) + node.value + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.text = function(node, level) {\n      return this.stream.write(this.space(level) + node.value + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.dtdAttList = function(node, level) {\n      this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);\n      if (node.defaultValueType !== '#DEFAULT') {\n        this.stream.write(' ' + node.defaultValueType);\n      }\n      if (node.defaultValue) {\n        this.stream.write(' \"' + node.defaultValue + '\"');\n      }\n      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.dtdElement = function(node, level) {\n      this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);\n      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.dtdEntity = function(node, level) {\n      this.stream.write(this.space(level) + '<!ENTITY');\n      if (node.pe) {\n        this.stream.write(' %');\n      }\n      this.stream.write(' ' + node.name);\n      if (node.value) {\n        this.stream.write(' \"' + node.value + '\"');\n      } else {\n        if (node.pubID && node.sysID) {\n          this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n        } else if (node.sysID) {\n          this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n        }\n        if (node.nData) {\n          this.stream.write(' NDATA ' + node.nData);\n        }\n      }\n      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.dtdNotation = function(node, level) {\n      this.stream.write(this.space(level) + '<!NOTATION ' + node.name);\n      if (node.pubID && node.sysID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n      } else if (node.pubID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\"');\n      } else if (node.sysID) {\n        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n      }\n      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.endline = function(node) {\n      if (!node.isLastRootNode) {\n        return this.newline;\n      } else {\n        return '';\n      }\n    };\n\n    return XMLStreamWriter;\n\n  })(XMLWriterBase);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLStreamWriter.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringWriter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"./node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n\n  XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"./node_modules/xmlbuilder/lib/XMLDocType.js\");\n\n  XMLCData = __webpack_require__(/*! ./XMLCData */ \"./node_modules/xmlbuilder/lib/XMLCData.js\");\n\n  XMLComment = __webpack_require__(/*! ./XMLComment */ \"./node_modules/xmlbuilder/lib/XMLComment.js\");\n\n  XMLElement = __webpack_require__(/*! ./XMLElement */ \"./node_modules/xmlbuilder/lib/XMLElement.js\");\n\n  XMLRaw = __webpack_require__(/*! ./XMLRaw */ \"./node_modules/xmlbuilder/lib/XMLRaw.js\");\n\n  XMLText = __webpack_require__(/*! ./XMLText */ \"./node_modules/xmlbuilder/lib/XMLText.js\");\n\n  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n\n  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ \"./node_modules/xmlbuilder/lib/XMLDTDAttList.js\");\n\n  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ \"./node_modules/xmlbuilder/lib/XMLDTDElement.js\");\n\n  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ \"./node_modules/xmlbuilder/lib/XMLDTDEntity.js\");\n\n  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ \"./node_modules/xmlbuilder/lib/XMLDTDNotation.js\");\n\n  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ \"./node_modules/xmlbuilder/lib/XMLWriterBase.js\");\n\n  module.exports = XMLStringWriter = (function(superClass) {\n    extend(XMLStringWriter, superClass);\n\n    function XMLStringWriter(options) {\n      XMLStringWriter.__super__.constructor.call(this, options);\n    }\n\n    XMLStringWriter.prototype.document = function(doc) {\n      var child, i, len, r, ref;\n      this.textispresent = false;\n      r = '';\n      ref = doc.children;\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        r += (function() {\n          switch (false) {\n            case !(child instanceof XMLDeclaration):\n              return this.declaration(child);\n            case !(child instanceof XMLDocType):\n              return this.docType(child);\n            case !(child instanceof XMLComment):\n              return this.comment(child);\n            case !(child instanceof XMLProcessingInstruction):\n              return this.processingInstruction(child);\n            default:\n              return this.element(child, 0);\n          }\n        }).call(this);\n      }\n      if (this.pretty && r.slice(-this.newline.length) === this.newline) {\n        r = r.slice(0, -this.newline.length);\n      }\n      return r;\n    };\n\n    XMLStringWriter.prototype.attribute = function(att) {\n      return ' ' + att.name + '=\"' + att.value + '\"';\n    };\n\n    XMLStringWriter.prototype.cdata = function(node, level) {\n      return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;\n    };\n\n    XMLStringWriter.prototype.comment = function(node, level) {\n      return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;\n    };\n\n    XMLStringWriter.prototype.declaration = function(node, level) {\n      var r;\n      r = this.space(level);\n      r += '<?xml version=\"' + node.version + '\"';\n      if (node.encoding != null) {\n        r += ' encoding=\"' + node.encoding + '\"';\n      }\n      if (node.standalone != null) {\n        r += ' standalone=\"' + node.standalone + '\"';\n      }\n      r += this.spacebeforeslash + '?>';\n      r += this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.docType = function(node, level) {\n      var child, i, len, r, ref;\n      level || (level = 0);\n      r = this.space(level);\n      r += '<!DOCTYPE ' + node.root().name;\n      if (node.pubID && node.sysID) {\n        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n      } else if (node.sysID) {\n        r += ' SYSTEM \"' + node.sysID + '\"';\n      }\n      if (node.children.length > 0) {\n        r += ' [';\n        r += this.newline;\n        ref = node.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          r += (function() {\n            switch (false) {\n              case !(child instanceof XMLDTDAttList):\n                return this.dtdAttList(child, level + 1);\n              case !(child instanceof XMLDTDElement):\n                return this.dtdElement(child, level + 1);\n              case !(child instanceof XMLDTDEntity):\n                return this.dtdEntity(child, level + 1);\n              case !(child instanceof XMLDTDNotation):\n                return this.dtdNotation(child, level + 1);\n              case !(child instanceof XMLCData):\n                return this.cdata(child, level + 1);\n              case !(child instanceof XMLComment):\n                return this.comment(child, level + 1);\n              case !(child instanceof XMLProcessingInstruction):\n                return this.processingInstruction(child, level + 1);\n              default:\n                throw new Error(\"Unknown DTD node type: \" + child.constructor.name);\n            }\n          }).call(this);\n        }\n        r += ']';\n      }\n      r += this.spacebeforeslash + '>';\n      r += this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.element = function(node, level) {\n      var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;\n      level || (level = 0);\n      textispresentwasset = false;\n      if (this.textispresent) {\n        this.newline = '';\n        this.pretty = false;\n      } else {\n        this.newline = this.newlinedefault;\n        this.pretty = this.prettydefault;\n      }\n      space = this.space(level);\n      r = '';\n      r += space + '<' + node.name;\n      ref = node.attributes;\n      for (name in ref) {\n        if (!hasProp.call(ref, name)) continue;\n        att = ref[name];\n        r += this.attribute(att);\n      }\n      if (node.children.length === 0 || node.children.every(function(e) {\n        return e.value === '';\n      })) {\n        if (this.allowEmpty) {\n          r += '></' + node.name + '>' + this.newline;\n        } else {\n          r += this.spacebeforeslash + '/>' + this.newline;\n        }\n      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {\n        r += '>';\n        r += node.children[0].value;\n        r += '</' + node.name + '>' + this.newline;\n      } else {\n        if (this.dontprettytextnodes) {\n          ref1 = node.children;\n          for (i = 0, len = ref1.length; i < len; i++) {\n            child = ref1[i];\n            if (child.value != null) {\n              this.textispresent++;\n              textispresentwasset = true;\n              break;\n            }\n          }\n        }\n        if (this.textispresent) {\n          this.newline = '';\n          this.pretty = false;\n          space = this.space(level);\n        }\n        r += '>' + this.newline;\n        ref2 = node.children;\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          child = ref2[j];\n          r += (function() {\n            switch (false) {\n              case !(child instanceof XMLCData):\n                return this.cdata(child, level + 1);\n              case !(child instanceof XMLComment):\n                return this.comment(child, level + 1);\n              case !(child instanceof XMLElement):\n                return this.element(child, level + 1);\n              case !(child instanceof XMLRaw):\n                return this.raw(child, level + 1);\n              case !(child instanceof XMLText):\n                return this.text(child, level + 1);\n              case !(child instanceof XMLProcessingInstruction):\n                return this.processingInstruction(child, level + 1);\n              default:\n                throw new Error(\"Unknown XML node type: \" + child.constructor.name);\n            }\n          }).call(this);\n        }\n        if (textispresentwasset) {\n          this.textispresent--;\n        }\n        if (!this.textispresent) {\n          this.newline = this.newlinedefault;\n          this.pretty = this.prettydefault;\n        }\n        r += space + '</' + node.name + '>' + this.newline;\n      }\n      return r;\n    };\n\n    XMLStringWriter.prototype.processingInstruction = function(node, level) {\n      var r;\n      r = this.space(level) + '<?' + node.target;\n      if (node.value) {\n        r += ' ' + node.value;\n      }\n      r += this.spacebeforeslash + '?>' + this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.raw = function(node, level) {\n      return this.space(level) + node.value + this.newline;\n    };\n\n    XMLStringWriter.prototype.text = function(node, level) {\n      return this.space(level) + node.value + this.newline;\n    };\n\n    XMLStringWriter.prototype.dtdAttList = function(node, level) {\n      var r;\n      r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;\n      if (node.defaultValueType !== '#DEFAULT') {\n        r += ' ' + node.defaultValueType;\n      }\n      if (node.defaultValue) {\n        r += ' \"' + node.defaultValue + '\"';\n      }\n      r += this.spacebeforeslash + '>' + this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.dtdElement = function(node, level) {\n      return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;\n    };\n\n    XMLStringWriter.prototype.dtdEntity = function(node, level) {\n      var r;\n      r = this.space(level) + '<!ENTITY';\n      if (node.pe) {\n        r += ' %';\n      }\n      r += ' ' + node.name;\n      if (node.value) {\n        r += ' \"' + node.value + '\"';\n      } else {\n        if (node.pubID && node.sysID) {\n          r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n        } else if (node.sysID) {\n          r += ' SYSTEM \"' + node.sysID + '\"';\n        }\n        if (node.nData) {\n          r += ' NDATA ' + node.nData;\n        }\n      }\n      r += this.spacebeforeslash + '>' + this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.dtdNotation = function(node, level) {\n      var r;\n      r = this.space(level) + '<!NOTATION ' + node.name;\n      if (node.pubID && node.sysID) {\n        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n      } else if (node.pubID) {\n        r += ' PUBLIC \"' + node.pubID + '\"';\n      } else if (node.sysID) {\n        r += ' SYSTEM \"' + node.sysID + '\"';\n      }\n      r += this.spacebeforeslash + '>' + this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.openNode = function(node, level) {\n      var att, name, r, ref;\n      level || (level = 0);\n      if (node instanceof XMLElement) {\n        r = this.space(level) + '<' + node.name;\n        ref = node.attributes;\n        for (name in ref) {\n          if (!hasProp.call(ref, name)) continue;\n          att = ref[name];\n          r += this.attribute(att);\n        }\n        r += (node.children ? '>' : '/>') + this.newline;\n        return r;\n      } else {\n        r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;\n        if (node.pubID && node.sysID) {\n          r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n        } else if (node.sysID) {\n          r += ' SYSTEM \"' + node.sysID + '\"';\n        }\n        r += (node.children ? ' [' : '>') + this.newline;\n        return r;\n      }\n    };\n\n    XMLStringWriter.prototype.closeNode = function(node, level) {\n      level || (level = 0);\n      switch (false) {\n        case !(node instanceof XMLElement):\n          return this.space(level) + '</' + node.name + '>' + this.newline;\n        case !(node instanceof XMLDocType):\n          return this.space(level) + ']>' + this.newline;\n      }\n    };\n\n    return XMLStringWriter;\n\n  })(XMLWriterBase);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLStringWriter.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringifier.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLStringifier,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    hasProp = {}.hasOwnProperty;\n\n  module.exports = XMLStringifier = (function() {\n    function XMLStringifier(options) {\n      this.assertLegalChar = bind(this.assertLegalChar, this);\n      var key, ref, value;\n      options || (options = {});\n      this.noDoubleEncoding = options.noDoubleEncoding;\n      ref = options.stringify || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n      }\n    }\n\n    XMLStringifier.prototype.eleName = function(val) {\n      val = '' + val || '';\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.eleText = function(val) {\n      val = '' + val || '';\n      return this.assertLegalChar(this.elEscape(val));\n    };\n\n    XMLStringifier.prototype.cdata = function(val) {\n      val = '' + val || '';\n      val = val.replace(']]>', ']]]]><![CDATA[>');\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.comment = function(val) {\n      val = '' + val || '';\n      if (val.match(/--/)) {\n        throw new Error(\"Comment text cannot contain double-hypen: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.raw = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.attName = function(val) {\n      return val = '' + val || '';\n    };\n\n    XMLStringifier.prototype.attValue = function(val) {\n      val = '' + val || '';\n      return this.attEscape(val);\n    };\n\n    XMLStringifier.prototype.insTarget = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.insValue = function(val) {\n      val = '' + val || '';\n      if (val.match(/\\?>/)) {\n        throw new Error(\"Invalid processing instruction value: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlVersion = function(val) {\n      val = '' + val || '';\n      if (!val.match(/1\\.[0-9]+/)) {\n        throw new Error(\"Invalid version number: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlEncoding = function(val) {\n      val = '' + val || '';\n      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {\n        throw new Error(\"Invalid encoding: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlStandalone = function(val) {\n      if (val) {\n        return \"yes\";\n      } else {\n        return \"no\";\n      }\n    };\n\n    XMLStringifier.prototype.dtdPubID = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdSysID = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdElementValue = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdAttType = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdAttDefault = function(val) {\n      if (val != null) {\n        return '' + val || '';\n      } else {\n        return val;\n      }\n    };\n\n    XMLStringifier.prototype.dtdEntityValue = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdNData = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.convertAttKey = '@';\n\n    XMLStringifier.prototype.convertPIKey = '?';\n\n    XMLStringifier.prototype.convertTextKey = '#text';\n\n    XMLStringifier.prototype.convertCDataKey = '#cdata';\n\n    XMLStringifier.prototype.convertCommentKey = '#comment';\n\n    XMLStringifier.prototype.convertRawKey = '#raw';\n\n    XMLStringifier.prototype.assertLegalChar = function(str) {\n      var res;\n      res = str.match(/[\\0\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/);\n      if (res) {\n        throw new Error(\"Invalid character in string: \" + str + \" at index \" + res.index);\n      }\n      return str;\n    };\n\n    XMLStringifier.prototype.elEscape = function(str) {\n      var ampregex;\n      ampregex = this.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\r/g, '&#xD;');\n    };\n\n    XMLStringifier.prototype.attEscape = function(str) {\n      var ampregex;\n      ampregex = this.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n    };\n\n    return XMLStringifier;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLStringifier.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLText.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLText.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNode, XMLText,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLText = (function(superClass) {\n    extend(XMLText, superClass);\n\n    function XMLText(parent, text) {\n      XMLText.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing element text\");\n      }\n      this.value = this.stringify.eleText(text);\n    }\n\n    XMLText.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLText.prototype.toString = function(options) {\n      return this.options.writer.set(options).text(this);\n    };\n\n    return XMLText;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLText.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLWriterBase.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLWriterBase.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLWriterBase,\n    hasProp = {}.hasOwnProperty;\n\n  module.exports = XMLWriterBase = (function() {\n    function XMLWriterBase(options) {\n      var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;\n      options || (options = {});\n      this.pretty = options.pretty || false;\n      this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;\n      if (this.pretty) {\n        this.indent = (ref1 = options.indent) != null ? ref1 : '  ';\n        this.newline = (ref2 = options.newline) != null ? ref2 : '\\n';\n        this.offset = (ref3 = options.offset) != null ? ref3 : 0;\n        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;\n      } else {\n        this.indent = '';\n        this.newline = '';\n        this.offset = 0;\n        this.dontprettytextnodes = 0;\n      }\n      this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';\n      if (this.spacebeforeslash === true) {\n        this.spacebeforeslash = ' ';\n      }\n      this.newlinedefault = this.newline;\n      this.prettydefault = this.pretty;\n      ref6 = options.writer || {};\n      for (key in ref6) {\n        if (!hasProp.call(ref6, key)) continue;\n        value = ref6[key];\n        this[key] = value;\n      }\n    }\n\n    XMLWriterBase.prototype.set = function(options) {\n      var key, ref, value;\n      options || (options = {});\n      if (\"pretty\" in options) {\n        this.pretty = options.pretty;\n      }\n      if (\"allowEmpty\" in options) {\n        this.allowEmpty = options.allowEmpty;\n      }\n      if (this.pretty) {\n        this.indent = \"indent\" in options ? options.indent : '  ';\n        this.newline = \"newline\" in options ? options.newline : '\\n';\n        this.offset = \"offset\" in options ? options.offset : 0;\n        this.dontprettytextnodes = \"dontprettytextnodes\" in options ? options.dontprettytextnodes : 0;\n      } else {\n        this.indent = '';\n        this.newline = '';\n        this.offset = 0;\n        this.dontprettytextnodes = 0;\n      }\n      this.spacebeforeslash = \"spacebeforeslash\" in options ? options.spacebeforeslash : '';\n      if (this.spacebeforeslash === true) {\n        this.spacebeforeslash = ' ';\n      }\n      this.newlinedefault = this.newline;\n      this.prettydefault = this.pretty;\n      ref = options.writer || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n      }\n      return this;\n    };\n\n    XMLWriterBase.prototype.space = function(level) {\n      var indent;\n      if (this.pretty) {\n        indent = (level || 0) + this.offset + 1;\n        if (indent > 0) {\n          return new Array(indent).join(this.indent);\n        } else {\n          return '';\n        }\n      } else {\n        return '';\n      }\n    };\n\n    return XMLWriterBase;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/XMLWriterBase.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;\n\n  ref = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\"), assign = ref.assign, isFunction = ref.isFunction;\n\n  XMLDocument = __webpack_require__(/*! ./XMLDocument */ \"./node_modules/xmlbuilder/lib/XMLDocument.js\");\n\n  XMLDocumentCB = __webpack_require__(/*! ./XMLDocumentCB */ \"./node_modules/xmlbuilder/lib/XMLDocumentCB.js\");\n\n  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ \"./node_modules/xmlbuilder/lib/XMLStringWriter.js\");\n\n  XMLStreamWriter = __webpack_require__(/*! ./XMLStreamWriter */ \"./node_modules/xmlbuilder/lib/XMLStreamWriter.js\");\n\n  module.exports.create = function(name, xmldec, doctype, options) {\n    var doc, root;\n    if (name == null) {\n      throw new Error(\"Root element needs a name\");\n    }\n    options = assign({}, xmldec, doctype, options);\n    doc = new XMLDocument(options);\n    root = doc.element(name);\n    if (!options.headless) {\n      doc.declaration(options);\n      if ((options.pubID != null) || (options.sysID != null)) {\n        doc.doctype(options);\n      }\n    }\n    return root;\n  };\n\n  module.exports.begin = function(options, onData, onEnd) {\n    var ref1;\n    if (isFunction(options)) {\n      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];\n      options = {};\n    }\n    if (onData) {\n      return new XMLDocumentCB(options, onData, onEnd);\n    } else {\n      return new XMLDocument(options);\n    }\n  };\n\n  module.exports.stringWriter = function(options) {\n    return new XMLStringWriter(options);\n  };\n\n  module.exports.streamWriter = function(stream, options) {\n    return new XMLStreamWriter(stream, options);\n  };\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/xmlbuilder/lib/index.js?");

/***/ }),

/***/ "./src/config/constants.js":
/*!*********************************!*\
  !*** ./src/config/constants.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst devConfig = {\n  MONGO_URL: 'mongodb://localhost:27017/supreme-posts-dev',\n  JWT_SECRET: 'thisIsASecret'\n};\n\nconst testConfig = {\n  MONGO_URL: 'mongodb://localhost:27017/supreme-posts-test'\n};\n\nconst prodConfig = {\n  MONGO_URL: 'mongodb://localhost:27017/supreme-posts-prod'\n};\n\nconst defaultConfig = {\n  PORT: process.env.PORT || 3000,\n  JWT_SECRET: 'thisIsASecret'\n};\n\nfunction envConfig(env) {\n  switch (env) {\n    case 'development':\n      return devConfig;\n    case 'test':\n      return testConfig;\n    default:\n      return prodConfig;\n  }\n}\n\nexports.default = Object.assign({}, defaultConfig, envConfig(\"development\"));\n\n//# sourceURL=webpack:///./src/config/constants.js?");

/***/ }),

/***/ "./src/config/database.js":
/*!********************************!*\
  !*** ./src/config/database.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./src/config/constants.js\");\n\nvar _constants2 = _interopRequireDefault(_constants);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_mongoose2.default.Promise = global.Promise;\n\ntry {\n  _mongoose2.default.connect(_constants2.default.MONGO_URL);\n} catch (err) {\n  _mongoose2.default.createConnection(_constants2.default.MONGO_URL);\n}\n\n_mongoose2.default.connection.once('open', () => console.log('MongodDB Running')).on('error', e => {\n  throw e;\n});\n\n//# sourceURL=webpack:///./src/config/database.js?");

/***/ }),

/***/ "./src/config/middlewares.js":
/*!***********************************!*\
  !*** ./src/config/middlewares.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _morgan = __webpack_require__(/*! morgan */ \"morgan\");\n\nvar _morgan2 = _interopRequireDefault(_morgan);\n\nvar _bodyParser = __webpack_require__(/*! body-parser */ \"body-parser\");\n\nvar _bodyParser2 = _interopRequireDefault(_bodyParser);\n\nvar _compression = __webpack_require__(/*! compression */ \"compression\");\n\nvar _compression2 = _interopRequireDefault(_compression);\n\nvar _helmet = __webpack_require__(/*! helmet */ \"helmet\");\n\nvar _helmet2 = _interopRequireDefault(_helmet);\n\nvar _passport = __webpack_require__(/*! passport */ \"passport\");\n\nvar _passport2 = _interopRequireDefault(_passport);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst isDev = \"development\" === 'development';\nconst isProd = \"development\" === 'production';\n\nexports.default = app => {\n  if (isProd) {\n    app.use((0, _compression2.default)());\n    app.use((0, _helmet2.default)());\n  }\n  app.use(_bodyParser2.default.json());\n  app.use(_bodyParser2.default.urlencoded({\n    extended: true\n  }));\n  app.use(_passport2.default.initialize());\n  if (isDev) {\n    app.use((0, _morgan2.default)('combined'));\n  }\n};\n\n//# sourceURL=webpack:///./src/config/middlewares.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _express = __webpack_require__(/*! express */ \"express\");\n\nvar _express2 = _interopRequireDefault(_express);\n\nvar _constants = __webpack_require__(/*! ./config/constants */ \"./src/config/constants.js\");\n\nvar _constants2 = _interopRequireDefault(_constants);\n\n__webpack_require__(/*! ./config/database */ \"./src/config/database.js\");\n\nvar _middlewares = __webpack_require__(/*! ./config/middlewares */ \"./src/config/middlewares.js\");\n\nvar _middlewares2 = _interopRequireDefault(_middlewares);\n\nvar _modules = __webpack_require__(/*! ./modules */ \"./src/modules/index.js\");\n\nvar _modules2 = _interopRequireDefault(_modules);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst app = (0, _express2.default)();\n(0, _middlewares2.default)(app);\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\n(0, _modules2.default)(app);\n\napp.listen(_constants2.default.PORT, err => {\n  if (err) {\n    throw err;\n  } else {\n    console.log(`\n       Server running on port: ${_constants2.default.PORT}\n       ---\n       Running on: ${\"development\"}\n       ---\n       Make something great\n       `);\n  }\n});\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/modules/articles/article.controllers.js":
/*!*****************************************************!*\
  !*** ./src/modules/articles/article.controllers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createArticle = createArticle;\nexports.getArticleById = getArticleById;\nexports.getArticlesList = getArticlesList;\nexports.updateArticle = updateArticle;\nexports.deleteArticle = deleteArticle;\nexports.favouriteArticle = favouriteArticle;\nexports.toReadArticle = toReadArticle;\n\nvar _httpStatus = __webpack_require__(/*! http-status */ \"http-status\");\n\nvar _httpStatus2 = _interopRequireDefault(_httpStatus);\n\nvar _minio = __webpack_require__(/*! ../../services/minio.services */ \"./src/services/minio.services.js\");\n\nvar _user = __webpack_require__(/*! ../users/user.model */ \"./src/modules/users/user.model.js\");\n\nvar _user2 = _interopRequireDefault(_user);\n\nvar _article = __webpack_require__(/*! ./article.model */ \"./src/modules/articles/article.model.js\");\n\nvar _article2 = _interopRequireDefault(_article);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nasync function createArticle(req, res) {\n  try {\n    const article = await _article2.default.createArticle(req.body, req.user._id);\n    await _article2.default.summarizeText(article, req.body.title, req.body.text);\n    if (req.file) await article.savePhoto(req.file);\n    return res.status(_httpStatus2.default.CREATED).json(article);\n  } catch (e) {\n    res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function getArticleById(req, res) {\n  try {\n    const promise = await Promise.all([_user2.default.findById(req.user._id), _article2.default.findById(req.params.id).populate('user')]);\n    const favourite = promise[0]._favourites.isArticleIsFavourite(req.params.id);\n    const article = promise[1];\n\n    var size = 0;\n    var data = \"\";\n    _minio.minioClient.getObject('europetrip', article.photo, (err, dataStream) => {\n      if (err) {\n        return console.log(err);\n      }\n      dataStream.on('data', chunk => {\n        size += chunk.length;\n        data += chunk;\n      });\n      dataStream.on('end', () => {\n        console.log('End. Total size = ' + size);\n        article.photo = data;\n        return res.status(_httpStatus2.default.OK).json(Object.assign({}, article.toJSON(), {\n          favourite\n        }));\n      });\n    });\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function getArticlesList(req, res) {\n  try {\n    const promise = await Promise.all([_user2.default.findById(req.user._id), _article2.default.list({\n      limit: parseInt(req.query.limit, 0),\n      skip: parseInt(req.query.skip, 0)\n    })]);\n\n    const articles = promise[1].reduce((arr, article) => {\n      const favourite = promise[0]._favourites.isArticleIsFavourite(article._id);\n      /*\n            var size = 0\n            var data = \"\"\n            minioClient.getObject('europetrip', article.photo, (err, dataStream) => {\n              if (err) {\n                return console.log(err)\n              }\n              dataStream.on('data', (chunk) => {\n                size += chunk.length\n                data += chunk\n              })\n              dataStream.on('end', () => {\n                console.log('End. Total size = ' + size)\n                article.photo = data\n              })\n            });\n      */\n      arr.push(Object.assign({}, article.toJSON(), {\n        favourite\n      }));\n\n      return arr;\n    }, []);\n\n    return res.status(_httpStatus2.default.OK).json(articles);\n  } catch (e) {\n    res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function updateArticle(req, res) {\n  try {\n    const article = await _article2.default.findById(req.params.id);\n    if (!article.user.equals(req.user._id)) {\n      return res.sendStatus(_httpStatus2.default.UNAUTHORIZED);\n    }\n    Object.keys(req.body).forEach(key => {\n      article[key] = req.body[key];\n    });\n    if (req.file)\n      //TODO make sure that the original file name is unique\n      await article.savePhoto(req.file);\n    return res.status(_httpStatus2.default.OK).json((await article.save()));\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function deleteArticle(req, res) {\n  try {\n    const article = await _article2.default.findById(req.params.id);\n    if (!article.user.equals(req.user._id)) {\n      return res.sendStatus(_httpStatus2.default.UNAUTHORIZED);\n    }\n    await article.remove();\n    return res.sendStatus(_httpStatus2.default.OK);\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function favouriteArticle(req, res) {\n  try {\n    const user = await _user2.default.findById(req.user._id);\n    await user._favourites.articles(req.params.id);\n    return res.sendStatus(_httpStatus2.default.OK);\n  } catch (e) {\n    res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function toReadArticle(req, res) {\n  try {\n    const user = await _user2.default.findById(req.user._id);\n    await user._toRead.articles(req.params.id);\n    return res.sendStatus(_httpStatus2.default.OK);\n  } catch (e) {\n    res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\n//# sourceURL=webpack:///./src/modules/articles/article.controllers.js?");

/***/ }),

/***/ "./src/modules/articles/article.model.js":
/*!***********************************************!*\
  !*** ./src/modules/articles/article.model.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nvar _slug = __webpack_require__(/*! slug */ \"slug\");\n\nvar _slug2 = _interopRequireDefault(_slug);\n\nvar _mongooseUniqueValidator = __webpack_require__(/*! mongoose-unique-validator */ \"mongoose-unique-validator\");\n\nvar _mongooseUniqueValidator2 = _interopRequireDefault(_mongooseUniqueValidator);\n\nvar _pythonShell = __webpack_require__(/*! python-shell */ \"python-shell\");\n\nvar _pythonShell2 = _interopRequireDefault(_pythonShell);\n\nvar _minio = __webpack_require__(/*! ../../services/minio.services */ \"./src/services/minio.services.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst ArticleSchema = new _mongoose.Schema({\n  title: {\n    type: String,\n    trim: true,\n    required: [true, 'Title is required'],\n    minlength: [3, 'Title need to be longer'],\n    maxlength: [24, 'Title need to be shorter'],\n    unique: true\n  },\n  text: {\n    type: String,\n    trim: true,\n    required: [true, 'Text is required'],\n    minlength: [10, 'Text need to be longer']\n  },\n  summary: {\n    type: String,\n    trim: true,\n    minLength: [10, 'Summary need to be longer']\n  },\n  photo: {\n    type: String,\n    trim: true\n  },\n  slug: {\n    type: String,\n    trim: true,\n    lowercase: true\n  },\n  user: {\n    type: _mongoose.Schema.Types.ObjectId,\n    ref: 'User'\n  },\n  favouriteCount: {\n    type: Number,\n    default: 0\n  },\n  toReadFlag: {\n    type: Boolean,\n    default: false\n  }\n}, {\n  timestamps: true\n});\n\nArticleSchema.plugin(_mongooseUniqueValidator2.default, {\n  message: '{VALUE} already taken!'\n});\n\nArticleSchema.pre('validate', function (next) {\n  this._slugify();\n  next();\n});\n\nArticleSchema.methods = {\n  _slugify() {\n    this.slug = (0, _slug2.default)(this.title);\n  },\n  toJSON() {\n    return {\n      _id: this._id,\n      title: this.title,\n      text: this.text,\n      summary: this.summary,\n      createdAt: this.createdAt,\n      user: this.user,\n      favoriteCount: this.favoriteCount,\n      photo: this.photo\n    };\n  },\n  savePhoto(photo) {\n    _minio.minioClient.putObject('europetrip', photo.originalname, photo.buffer, \"application/octet-stream\", function (error, etag) {\n      if (error) {\n        return console.log(error);\n      }\n      console.log('File uploaded successfully.');\n    });\n    this.photo = photo.originalname;\n    this.save();\n  }\n};\n\nArticleSchema.statics = {\n  createArticle(args, user) {\n    return this.create(Object.assign({}, args, {\n      user\n    }));\n  },\n  list({\n    skip = 0,\n    limit = 5\n  } = {}) {\n    return this.find().sort({\n      createdAt: -1\n    }).skip(skip).limit(limit).populate('user');\n  },\n  summarizeText(post, title, text) {\n    console.log('inside summarizeText');\n    const shellOptions = {\n      pythonPath: '/usr/bin/python3',\n      pythonOptions: ['-u'],\n      args: [title, text]\n    };\n    const shell = new _pythonShell2.default('/Summarization/Engine/predicter.py', shellOptions);\n    shell.on('message', summary => {\n      console.log(summary);\n      post.summary = summary;\n      post.save();\n    });\n    shell.end((err, code, signal) => {\n      if (err) throw err;\n      console.log('The exit code was: ', code);\n      console.log('The exit signal was: ', signal);\n      console.log('python-shell has finished excuting');\n    });\n  },\n  incFavourite(articleId) {\n    return this.findByIdAndUpdate(articleId, { $inc: { favouriteCount: 1 } });\n  },\n  decFavourite(articleId) {\n    return this.findByIdAndUpdate(articleId, { $inc: { favouriteCount: -1 } });\n  },\n  addToRead(articleId) {\n    return this.findByIdAndUpdate(articleId, { toReadFlag: true });\n  },\n  removeToRead(articleId) {\n    return this.findByIdAndUpdate(articleId, { toReadFlag: false });\n  }\n};\n\nexports.default = _mongoose2.default.model('Article', ArticleSchema);\n\n//# sourceURL=webpack:///./src/modules/articles/article.model.js?");

/***/ }),

/***/ "./src/modules/articles/article.routes.js":
/*!************************************************!*\
  !*** ./src/modules/articles/article.routes.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _express = __webpack_require__(/*! express */ \"express\");\n\nvar _expressValidation = __webpack_require__(/*! express-validation */ \"express-validation\");\n\nvar _expressValidation2 = _interopRequireDefault(_expressValidation);\n\nvar _multer = __webpack_require__(/*! multer */ \"multer\");\n\nvar _multer2 = _interopRequireDefault(_multer);\n\nvar _article = __webpack_require__(/*! ./article.validations */ \"./src/modules/articles/article.validations.js\");\n\nvar _article2 = _interopRequireDefault(_article);\n\nvar _article3 = __webpack_require__(/*! ./article.controllers */ \"./src/modules/articles/article.controllers.js\");\n\nvar articleController = _interopRequireWildcard(_article3);\n\nvar _auth = __webpack_require__(/*! ../../services/auth.services */ \"./src/services/auth.services.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst routes = new _express.Router();\n\nroutes.post('/', _auth.authJwt, (0, _multer2.default)({ storage: _multer2.default.memoryStorage() }).single(\"photo\"), (0, _expressValidation2.default)(_article2.default.createArticle), articleController.createArticle);\nroutes.get('/:id', _auth.authJwt, articleController.getArticleById);\nroutes.get('/', _auth.authJwt, articleController.getArticlesList);\nroutes.patch('/:id', _auth.authJwt, (0, _multer2.default)({ storage: _multer2.default.memoryStorage() }).single(\"photo\"), (0, _expressValidation2.default)(_article2.default.updateArticle), articleController.updateArticle);\nroutes.delete('/:id', _auth.authJwt, articleController.deleteArticle);\nroutes.post('/:id/favourite', _auth.authJwt, articleController.favouriteArticle);\nroutes.post('/:id/toread', _auth.authJwt, articleController.toReadArticle);\n\nexports.default = routes;\n\n//# sourceURL=webpack:///./src/modules/articles/article.routes.js?");

/***/ }),

/***/ "./src/modules/articles/article.validations.js":
/*!*****************************************************!*\
  !*** ./src/modules/articles/article.validations.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _joi = __webpack_require__(/*! joi */ \"joi\");\n\nvar _joi2 = _interopRequireDefault(_joi);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  createArticle: {\n    body: {\n      title: _joi2.default.string().min(3).max(24).required(),\n      text: _joi2.default.string().min(10).required()\n    }\n  },\n  updateArticle: {\n    body: {\n      title: _joi2.default.string().min(3).max(24),\n      text: _joi2.default.string().min(10)\n    }\n  }\n};\n\n//# sourceURL=webpack:///./src/modules/articles/article.validations.js?");

/***/ }),

/***/ "./src/modules/collections/collection.controllers.js":
/*!***********************************************************!*\
  !*** ./src/modules/collections/collection.controllers.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCollection = createCollection;\nexports.updateCollection = updateCollection;\nexports.getCollectionById = getCollectionById;\nexports.addArticleToCollection = addArticleToCollection;\nexports.deleteCollection = deleteCollection;\nexports.getUserCollections = getUserCollections;\n\nvar _httpStatus = __webpack_require__(/*! http-status */ \"http-status\");\n\nvar _httpStatus2 = _interopRequireDefault(_httpStatus);\n\nvar _collection = __webpack_require__(/*! ./collection.model */ \"./src/modules/collections/collection.model.js\");\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _user = __webpack_require__(/*! ../users/user.model */ \"./src/modules/users/user.model.js\");\n\nvar _user2 = _interopRequireDefault(_user);\n\nvar _minio = __webpack_require__(/*! ../../services/minio.services */ \"./src/services/minio.services.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nasync function createCollection(req, res) {\n  try {\n    const collection = await _collection2.default.createCollection(req.body, req.user._id);\n    if (req.file)\n      //TODO make sure that the original file name is unique\n      await collection.savePhoto(req.file);\n    return res.status(_httpStatus2.default.CREATED).json(collection);\n  } catch (e) {\n    res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function updateCollection(req, res) {\n  try {\n    const collection = await _collection2.default.findById(req.params.id);\n    if (!collection.user.equals(req.user._id)) {\n      return res.sendStatus(_httpStatus2.default.UNAUTHORIZED);\n    }\n    Object.keys(req.body).forEach(key => {\n      collection[key] = req.body[key];\n    });\n    if (req.file)\n      //TODO make sure that the original file name is unique\n      await collection.savePhoto(req.file);\n    return res.status(_httpStatus2.default.OK).json((await collection.save()));\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function getCollectionById(req, res, next) {\n  try {\n    const collection = await _collection2.default.findById(req.params.id).populate('articles').populate('user');\n    if (collection.photo) {\n      var size = 0;\n      var data = \"\";\n      _minio.minioClient.getObject('europetrip', collection.photo, (err, dataStream) => {\n        if (err) {\n          return console.log(err);\n        }\n        dataStream.on('data', chunk => {\n          size += chunk.length;\n          data += chunk;\n        });\n        dataStream.on('end', () => {\n          console.log('End. Total size = ' + size);\n          collection.photo = data;\n          res.status(_httpStatus2.default.OK).json(collection);\n          return next();\n        });\n      });\n    } else {\n      res.status(_httpStatus2.default.OK).json(collection);\n      return next();\n    }\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function addArticleToCollection(req, res) {\n  try {\n    const collection = await _collection2.default.findById(req.params.cid);\n    console.log(collection);\n    await collection._articles.add(req.params.aid);\n    return res.sendStatus(_httpStatus2.default.OK);\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function deleteCollection(req, res) {\n  try {\n    const collection = await _collection2.default.findById(req.params.id);\n    if (!collection.user.equals(req.user._id)) {\n      return res.sendStatus(_httpStatus2.default.UNAUTHORIZED);\n    }\n    await collection.remove();\n    return res.sendStatus(_httpStatus2.default.OK);\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function getUserCollections(req, res) {\n  try {\n    const collections = await _collection2.default.find({ user: req.params.uid }).populate('articles');\n    return res.status(_httpStatus2.default.OK).json(collections);\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\n//# sourceURL=webpack:///./src/modules/collections/collection.controllers.js?");

/***/ }),

/***/ "./src/modules/collections/collection.model.js":
/*!*****************************************************!*\
  !*** ./src/modules/collections/collection.model.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nvar _slug = __webpack_require__(/*! slug */ \"slug\");\n\nvar _slug2 = _interopRequireDefault(_slug);\n\nvar _minio = __webpack_require__(/*! ../../services/minio.services */ \"./src/services/minio.services.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst CollectionSchema = new _mongoose.Schema({\n  title: {\n    type: String,\n    trim: true,\n    required: [true, 'Collection title is requires'],\n    minlength: [3, 'Title need to be longer'],\n    maxlength: [24, 'Title need to be shorter'],\n    unique: true\n  },\n  description: {\n    type: String,\n    trim: true,\n    required: false,\n    minlength: [5, 'Description need to be longer'],\n    maxlength: [48, 'Description need to be shorter']\n  },\n  photo: {\n    type: String,\n    trim: true\n  },\n  user: {\n    type: _mongoose.Schema.Types.ObjectId,\n    ref: 'User'\n  },\n  articles: [{\n    type: _mongoose.Schema.Types.ObjectId,\n    ref: 'Article'\n  }]\n}, {\n  timestamps: true\n});\n\nCollectionSchema.methods = {\n  toJSON() {\n    return {\n      _id: this._id,\n      title: this.title,\n      description: this.description,\n      photo: this.photo,\n      user: this.user,\n      articles: this.articles,\n      createdAt: this.createdAt\n    };\n  },\n  savePhoto(photo) {\n    _minio.minioClient.putObject('europetrip', photo.originalname, photo.buffer, \"application/octet-stream\", function (error, etag) {\n      if (error) {\n        return console.log(error);\n      }\n      console.log('File uploaded successfully.');\n    });\n    this.photo = photo.originalname;\n    this.save();\n  },\n  _articles: {\n    add(articleId) {\n      if (this.articles.indexOf(articleId) >= 0) {\n        console.log('removing article from collection');\n        this.articles.remove(articleId);\n      } else {\n        console.log('adding article to collection');\n        this.articles.push(articleId);\n      }\n      this.save();\n    }\n  }\n};\n\nCollectionSchema.statics = {\n  createCollection(args, user) {\n    return this.create(Object.assign({}, args, {\n      user\n    }));\n  }\n};\n\nexports.default = _mongoose2.default.model('Collection', CollectionSchema);\n\n//# sourceURL=webpack:///./src/modules/collections/collection.model.js?");

/***/ }),

/***/ "./src/modules/collections/collection.routes.js":
/*!******************************************************!*\
  !*** ./src/modules/collections/collection.routes.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _express = __webpack_require__(/*! express */ \"express\");\n\nvar _expressValidation = __webpack_require__(/*! express-validation */ \"express-validation\");\n\nvar _expressValidation2 = _interopRequireDefault(_expressValidation);\n\nvar _multer = __webpack_require__(/*! multer */ \"multer\");\n\nvar _multer2 = _interopRequireDefault(_multer);\n\nvar _collection = __webpack_require__(/*! ./collection.validations */ \"./src/modules/collections/collection.validations.js\");\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _collection3 = __webpack_require__(/*! ./collection.controllers */ \"./src/modules/collections/collection.controllers.js\");\n\nvar collectionController = _interopRequireWildcard(_collection3);\n\nvar _auth = __webpack_require__(/*! ../../services/auth.services */ \"./src/services/auth.services.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst routes = new _express.Router();\n\nroutes.post('/', _auth.authJwt, (0, _multer2.default)({ storage: _multer2.default.memoryStorage() }).single(\"photo\"), (0, _expressValidation2.default)(_collection2.default.createCollection), collectionController.createCollection);\nroutes.patch('/:id', _auth.authJwt, (0, _multer2.default)({ storage: _multer2.default.memoryStorage() }).single(\"photo\"), (0, _expressValidation2.default)(_collection2.default.updateCollection), collectionController.updateCollection);\nroutes.get('/:id', _auth.authJwt, collectionController.getCollectionById);\nroutes.post('/:cid/:aid', _auth.authJwt, collectionController.addArticleToCollection); // performs the add and delete (if the requested article already exists it got deleted)\nroutes.delete('/:id', _auth.authJwt, collectionController.deleteCollection);\nroutes.get('/user/:uid', _auth.authJwt, collectionController.getUserCollections);\n\nexports.default = routes;\n\n//# sourceURL=webpack:///./src/modules/collections/collection.routes.js?");

/***/ }),

/***/ "./src/modules/collections/collection.validations.js":
/*!***********************************************************!*\
  !*** ./src/modules/collections/collection.validations.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _joi = __webpack_require__(/*! joi */ \"joi\");\n\nvar _joi2 = _interopRequireDefault(_joi);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  createCollection: {\n    body: {\n      title: _joi2.default.string().min(3).max(24).required(),\n      description: _joi2.default.string().min(10).max(48)\n    }\n  },\n  updateCollection: {\n    body: {\n      title: _joi2.default.string().min(5).max(24),\n      description: _joi2.default.string().min(10).max(48)\n    }\n  }\n};\n\n//# sourceURL=webpack:///./src/modules/collections/collection.validations.js?");

/***/ }),

/***/ "./src/modules/index.js":
/*!******************************!*\
  !*** ./src/modules/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _user = __webpack_require__(/*! ./users/user.routes */ \"./src/modules/users/user.routes.js\");\n\nvar _user2 = _interopRequireDefault(_user);\n\nvar _article = __webpack_require__(/*! ./articles/article.routes */ \"./src/modules/articles/article.routes.js\");\n\nvar _article2 = _interopRequireDefault(_article);\n\nvar _collection = __webpack_require__(/*! ./collections/collection.routes */ \"./src/modules/collections/collection.routes.js\");\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = app => {\n  app.use('/api/v1/users', _user2.default);\n  app.use('/api/v1/articles', _article2.default);\n  app.use('/api/v1/collections', _collection2.default);\n};\n\n//# sourceURL=webpack:///./src/modules/index.js?");

/***/ }),

/***/ "./src/modules/users/user.controllers.js":
/*!***********************************************!*\
  !*** ./src/modules/users/user.controllers.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.signup = signup;\nexports.login = login;\nexports.follow = follow;\nexports.update = update;\n\nvar _httpStatus = __webpack_require__(/*! http-status */ \"http-status\");\n\nvar _httpStatus2 = _interopRequireDefault(_httpStatus);\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _user = __webpack_require__(/*! ./user.model */ \"./src/modules/users/user.model.js\");\n\nvar _user2 = _interopRequireDefault(_user);\n\nvar _minio = __webpack_require__(/*! ../../services/minio.services */ \"./src/services/minio.services.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nasync function signup(req, res) {\n  try {\n    const user = await _user2.default.create(req.body);\n    return res.status(_httpStatus2.default.CREATED).json(user.toAuthJSON());\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nfunction login(req, res, next) {\n  try {\n    const user = req.user.toAuthJSON();\n    if (user.photo) {\n      var size = 0;\n      var data = \"\";\n      _minio.minioClient.getObject('europetrip', user.photo, (err, dataStream) => {\n        if (err) {\n          return console.log(err);\n        }\n        dataStream.on('data', chunk => {\n          size += chunk.length;\n          data += chunk;\n        });\n        dataStream.on('end', () => {\n          console.log('End. Total size = ' + size);\n          user.photo = data;\n          res.status(_httpStatus2.default.OK).json(user);\n          return next();\n        });\n      });\n    } else {\n      res.status(_httpStatus2.default.OK).json(user);\n      return next();\n    }\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function follow(req, res) {\n  try {\n    const user = await _user2.default.findById(req.user._id);\n    await user._followings.add(req.params.id);\n    await _user2.default.checkFollower(req.params.id, req.user.id);\n    return res.sendStatus(_httpStatus2.default.OK);\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\nasync function update(req, res) {\n  try {\n    const user = await _user2.default.findById(req.user._id);\n    Object.keys(req.body).forEach(key => {\n      user[key] = req.body[key];\n    });\n    if (req.file)\n      //TODO make sure that the original file name is unique\n      await user.savePhoto(req.file);\n    return res.status(_httpStatus2.default.OK).json((await user.save()));\n  } catch (e) {\n    return res.status(_httpStatus2.default.BAD_REQUEST).json(e);\n  }\n}\n\n//# sourceURL=webpack:///./src/modules/users/user.controllers.js?");

/***/ }),

/***/ "./src/modules/users/user.model.js":
/*!*****************************************!*\
  !*** ./src/modules/users/user.model.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nvar _validator = __webpack_require__(/*! validator */ \"validator\");\n\nvar _validator2 = _interopRequireDefault(_validator);\n\nvar _bcryptNodejs = __webpack_require__(/*! bcrypt-nodejs */ \"bcrypt-nodejs\");\n\nvar _jsonwebtoken = __webpack_require__(/*! jsonwebtoken */ \"jsonwebtoken\");\n\nvar _jsonwebtoken2 = _interopRequireDefault(_jsonwebtoken);\n\nvar _mongooseUniqueValidator = __webpack_require__(/*! mongoose-unique-validator */ \"mongoose-unique-validator\");\n\nvar _mongooseUniqueValidator2 = _interopRequireDefault(_mongooseUniqueValidator);\n\nvar _minio = __webpack_require__(/*! ../../services/minio.services */ \"./src/services/minio.services.js\");\n\nvar _constants = __webpack_require__(/*! ../../config/constants */ \"./src/config/constants.js\");\n\nvar _constants2 = _interopRequireDefault(_constants);\n\nvar _article = __webpack_require__(/*! ../articles/article.model */ \"./src/modules/articles/article.model.js\");\n\nvar _article2 = _interopRequireDefault(_article);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst UserSchema = new _mongoose.Schema({\n  email: {\n    type: String,\n    unique: true,\n    required: true,\n    trim: true,\n    validate: {\n      validator(email) {\n        return _validator2.default.isEmail(email);\n      },\n      message: '{VALUE} is not a valid email!'\n    }\n  },\n  firstName: {\n    type: String,\n    required: [true, 'First name is required'],\n    trim: true\n  },\n  lastName: {\n    type: String,\n    required: [true, 'Last name is required'],\n    trim: true\n  },\n  userName: {\n    type: String,\n    required: [true, 'User name is required'],\n    trim: true,\n    unique: true\n  },\n  photo: {\n    type: String,\n    trim: true\n  },\n  password: {\n    type: String,\n    required: [true, 'Password is required'],\n    trim: true,\n    minlength: [6, 'Password need to be longer']\n  },\n  favourites: {\n    articles: [{\n      type: _mongoose.Schema.Types.ObjectId,\n      ref: 'Article'\n    }]\n  },\n  toRead: {\n    articles: [{\n      type: _mongoose.Schema.Types.ObjectId,\n      ref: 'Article'\n    }]\n  },\n  followings: [{\n    type: _mongoose.Schema.Types.ObjectId,\n    ref: 'User'\n  }],\n  followers: [{\n    type: _mongoose.Schema.Types.ObjectId,\n    ref: 'User'\n  }]\n}, {\n  timestamps: true\n});\n\nUserSchema.plugin(_mongooseUniqueValidator2.default, {\n  message: '{VALUE} already taken!'\n});\n\nUserSchema.pre('save', function (next) {\n  if (this.isModified('password')) {\n    this.password = this._hashPassword(this.password);\n  }\n  return next();\n});\n\nUserSchema.methods = {\n  _hashPassword(password) {\n    return (0, _bcryptNodejs.hashSync)(password);\n  },\n  authenticateUser(password) {\n    return (0, _bcryptNodejs.compareSync)(password, this.password);\n  },\n  createToken() {\n    return _jsonwebtoken2.default.sign({\n      _id: this._id\n    }, _constants2.default.JWT_SECRET);\n  },\n  toAuthJSON() {\n    return {\n      _id: this._id,\n      userName: this.userName,\n      photo: this.photo,\n      token: `JWT ${this.createToken()}`\n    };\n  },\n  toJSON() {\n    return {\n      _id: this._id,\n      userName: this.userName,\n      firstName: this.firstName,\n      lastName: this.lastName,\n      photo: this.photo\n    };\n  },\n  savePhoto(photo) {\n    _minio.minioClient.putObject('europetrip', photo.originalname, photo.buffer, \"application/octet-stream\", function (error, etag) {\n      if (error) {\n        return console.log(error);\n      }\n      console.log('File uploaded successfully.');\n    });\n    this.photo = photo.originalname;\n    this.save();\n  },\n  _favourites: {\n    async articles(articleId) {\n      if (this.favourites.articles.indexOf(articleId) >= 0) {\n        this.favourites.articles.remove(articleId);\n        await _article2.default.decFavourite(articleId);\n      } else {\n        this.favourites.articles.push(articleId);\n        await _article2.default.incFavourite(articleId);\n      }\n      return this.save();\n    },\n    isArticleIsFavourite(articleId) {\n      if (this.favourites.articles.indexOf(articleId) >= 0) {\n        return true;\n      }\n      return false;\n    }\n  },\n  _toRead: {\n    async articles(articleId) {\n      if (this.toRead.articles.indexOf(articleId) >= 0) {\n        this.toRead.articles.remove(articleId);\n        await _article2.default.removeToRead(articleId);\n      } else {\n        this.toRead.articles.push(articleId);\n        await _article2.default.addToRead(articleId);\n      }\n      return this.save();\n    }\n  },\n  _followings: {\n    async add(userId) {\n      if (this.followings.indexOf(userId) >= 0) {\n        console.log('removing user from following list');\n        this.followings.remove(userId);\n      } else {\n        console.log('adding new user to following list');\n        this.followings.push(userId);\n      }\n      this.save();\n    }\n  },\n  _followers: {\n    async add(userId) {\n      if (this.followers.indexOf(userId) >= 0) {\n        console.log('removing user from followers list');\n        this.followers.remove(userId);\n      } else {\n        console.log('adding new user to followers list');\n        this.followers.push(userId);\n      }\n      this.save();\n    }\n  }\n};\n\nUserSchema.statics = {\n  async checkFollower(currentId, followerId) {\n    const user = await this.findById(currentId);\n    user._followers.add(followerId);\n  }\n};\n\nexports.default = _mongoose2.default.model('User', UserSchema);\n\n//# sourceURL=webpack:///./src/modules/users/user.model.js?");

/***/ }),

/***/ "./src/modules/users/user.routes.js":
/*!******************************************!*\
  !*** ./src/modules/users/user.routes.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _express = __webpack_require__(/*! express */ \"express\");\n\nvar _path = __webpack_require__(/*! path */ \"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _multer = __webpack_require__(/*! multer */ \"multer\");\n\nvar _multer2 = _interopRequireDefault(_multer);\n\nvar _minio = __webpack_require__(/*! minio */ \"./node_modules/minio/dist/main/minio.js\");\n\nvar _minio2 = _interopRequireDefault(_minio);\n\nvar _auth = __webpack_require__(/*! ../../services/auth.services */ \"./src/services/auth.services.js\");\n\nvar _user = __webpack_require__(/*! ./user.controllers */ \"./src/modules/users/user.controllers.js\");\n\nvar userController = _interopRequireWildcard(_user);\n\nvar _minio3 = __webpack_require__(/*! ../../services/minio.services */ \"./src/services/minio.services.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst routes = new _express.Router();\n\nroutes.post('/signup', userController.signup);\nroutes.post('/login', _auth.authLocal, userController.login);\nroutes.post('/:id/follow', _auth.authJwt, userController.follow);\nroutes.patch('/update', _auth.authJwt, (0, _multer2.default)({ storage: _multer2.default.memoryStorage() }).single(\"photo\"), userController.update);\n\nexports.default = routes;\n\n//# sourceURL=webpack:///./src/modules/users/user.routes.js?");

/***/ }),

/***/ "./src/services/auth.services.js":
/*!***************************************!*\
  !*** ./src/services/auth.services.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.authJwt = exports.authLocal = undefined;\n\nvar _passport = __webpack_require__(/*! passport */ \"passport\");\n\nvar _passport2 = _interopRequireDefault(_passport);\n\nvar _passportLocal = __webpack_require__(/*! passport-local */ \"passport-local\");\n\nvar _passportLocal2 = _interopRequireDefault(_passportLocal);\n\nvar _passportJwt = __webpack_require__(/*! passport-jwt */ \"passport-jwt\");\n\nvar _user = __webpack_require__(/*! ../modules/users/user.model */ \"./src/modules/users/user.model.js\");\n\nvar _user2 = _interopRequireDefault(_user);\n\nvar _constants = __webpack_require__(/*! ../config/constants */ \"./src/config/constants.js\");\n\nvar _constants2 = _interopRequireDefault(_constants);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Local strategy\nconst localOpts = {\n  usernameField: 'email'\n};\n\nconst localStrategy = new _passportLocal2.default(localOpts, async (email, password, done) => {\n  try {\n    const user = await _user2.default.findOne({ email });\n    if (!user) {\n      return done(null, false);\n    } else if (!user.authenticateUser(password)) {\n      return done(null, false);\n    }\n\n    return done(null, user);\n  } catch (e) {\n    return done(e, false);\n  }\n});\n\n// Jwt strategy\nconst jwtOpts = {\n  jwtFromRequest: _passportJwt.ExtractJwt.fromAuthHeaderWithScheme('jwt'),\n  secretOrKey: _constants2.default.JWT_SECRET\n};\n\nconst jwtStrategy = new _passportJwt.Strategy(jwtOpts, async (payload, done) => {\n  try {\n    const user = await _user2.default.findById(payload._id);\n\n    if (!user) {\n      return done(null, false);\n    }\n\n    return done(null, user);\n  } catch (e) {\n    return done(e, false);\n  }\n});\n\n_passport2.default.use(localStrategy);\n_passport2.default.use(jwtStrategy);\n\nconst authLocal = exports.authLocal = _passport2.default.authenticate('local', { session: false });\nconst authJwt = exports.authJwt = _passport2.default.authenticate('jwt', { session: false });\n\n//# sourceURL=webpack:///./src/services/auth.services.js?");

/***/ }),

/***/ "./src/services/minio.services.js":
/*!****************************************!*\
  !*** ./src/services/minio.services.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.minioClient = undefined;\n\nvar _minio = __webpack_require__(/*! minio */ \"./node_modules/minio/dist/main/minio.js\");\n\nconst minioClient = exports.minioClient = new _minio.Client({\n    endPoint: 'play.minio.io',\n    port: 9000,\n    secure: true,\n    accessKey: 'Q3AM3UQ867SPQQA43P2F',\n    secretKey: 'zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG'\n});\n\n//# sourceURL=webpack:///./src/services/minio.services.js?");

/***/ }),

/***/ "async":
/*!************************!*\
  !*** external "async" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"async\");\n\n//# sourceURL=webpack:///external_%22async%22?");

/***/ }),

/***/ "bcrypt-nodejs":
/*!********************************!*\
  !*** external "bcrypt-nodejs" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"bcrypt-nodejs\");\n\n//# sourceURL=webpack:///external_%22bcrypt-nodejs%22?");

/***/ }),

/***/ "body-parser":
/*!******************************!*\
  !*** external "body-parser" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"body-parser\");\n\n//# sourceURL=webpack:///external_%22body-parser%22?");

/***/ }),

/***/ "compression":
/*!******************************!*\
  !*** external "compression" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"compression\");\n\n//# sourceURL=webpack:///external_%22compression%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"express\");\n\n//# sourceURL=webpack:///external_%22express%22?");

/***/ }),

/***/ "express-validation":
/*!*************************************!*\
  !*** external "express-validation" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"express-validation\");\n\n//# sourceURL=webpack:///external_%22express-validation%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "helmet":
/*!*************************!*\
  !*** external "helmet" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"helmet\");\n\n//# sourceURL=webpack:///external_%22helmet%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack:///external_%22http%22?");

/***/ }),

/***/ "http-status":
/*!******************************!*\
  !*** external "http-status" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http-status\");\n\n//# sourceURL=webpack:///external_%22http-status%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=webpack:///external_%22https%22?");

/***/ }),

/***/ "inherits":
/*!***************************!*\
  !*** external "inherits" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"inherits\");\n\n//# sourceURL=webpack:///external_%22inherits%22?");

/***/ }),

/***/ "joi":
/*!**********************!*\
  !*** external "joi" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"joi\");\n\n//# sourceURL=webpack:///external_%22joi%22?");

/***/ }),

/***/ "jsonwebtoken":
/*!*******************************!*\
  !*** external "jsonwebtoken" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"jsonwebtoken\");\n\n//# sourceURL=webpack:///external_%22jsonwebtoken%22?");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lodash\");\n\n//# sourceURL=webpack:///external_%22lodash%22?");

/***/ }),

/***/ "mime-types":
/*!*****************************!*\
  !*** external "mime-types" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"mime-types\");\n\n//# sourceURL=webpack:///external_%22mime-types%22?");

/***/ }),

/***/ "mkdirp":
/*!*************************!*\
  !*** external "mkdirp" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"mkdirp\");\n\n//# sourceURL=webpack:///external_%22mkdirp%22?");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"mongoose\");\n\n//# sourceURL=webpack:///external_%22mongoose%22?");

/***/ }),

/***/ "mongoose-unique-validator":
/*!********************************************!*\
  !*** external "mongoose-unique-validator" ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"mongoose-unique-validator\");\n\n//# sourceURL=webpack:///external_%22mongoose-unique-validator%22?");

/***/ }),

/***/ "morgan":
/*!*************************!*\
  !*** external "morgan" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"morgan\");\n\n//# sourceURL=webpack:///external_%22morgan%22?");

/***/ }),

/***/ "multer":
/*!*************************!*\
  !*** external "multer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"multer\");\n\n//# sourceURL=webpack:///external_%22multer%22?");

/***/ }),

/***/ "passport":
/*!***************************!*\
  !*** external "passport" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"passport\");\n\n//# sourceURL=webpack:///external_%22passport%22?");

/***/ }),

/***/ "passport-jwt":
/*!*******************************!*\
  !*** external "passport-jwt" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"passport-jwt\");\n\n//# sourceURL=webpack:///external_%22passport-jwt%22?");

/***/ }),

/***/ "passport-local":
/*!*********************************!*\
  !*** external "passport-local" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"passport-local\");\n\n//# sourceURL=webpack:///external_%22passport-local%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "python-shell":
/*!*******************************!*\
  !*** external "python-shell" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"python-shell\");\n\n//# sourceURL=webpack:///external_%22python-shell%22?");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"querystring\");\n\n//# sourceURL=webpack:///external_%22querystring%22?");

/***/ }),

/***/ "readable-stream":
/*!**********************************!*\
  !*** external "readable-stream" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"readable-stream\");\n\n//# sourceURL=webpack:///external_%22readable-stream%22?");

/***/ }),

/***/ "slug":
/*!***********************!*\
  !*** external "slug" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"slug\");\n\n//# sourceURL=webpack:///external_%22slug%22?");

/***/ }),

/***/ "source-map-support":
/*!*************************************!*\
  !*** external "source-map-support" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"source-map-support\");\n\n//# sourceURL=webpack:///external_%22source-map-support%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=webpack:///external_%22stream%22?");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"string_decoder\");\n\n//# sourceURL=webpack:///external_%22string_decoder%22?");

/***/ }),

/***/ "through2":
/*!***************************!*\
  !*** external "through2" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"through2\");\n\n//# sourceURL=webpack:///external_%22through2%22?");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"timers\");\n\n//# sourceURL=webpack:///external_%22timers%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ }),

/***/ "validator":
/*!****************************!*\
  !*** external "validator" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"validator\");\n\n//# sourceURL=webpack:///external_%22validator%22?");

/***/ })

/******/ });